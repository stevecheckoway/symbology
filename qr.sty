\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{qr}
  [2016/04/20 v1.0 Construct QR codes]

\RequirePackage{etoolbox}
\RequirePackage{xcolor}
\RequirePackage{trace}

\newdimen\qr@width
\newcount\qr@len
\newcount\qr@gf@a
\newcount\qr@gf@b
\newcount\qr@gf@r
\newcount\qr@gf@n
\newcount\qr@a
\newcount\qr@b
\newcount\qr@c
\newcount\qr@idx
\newif\ifqr@inrange

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Global \chardef of a control sequence.
%
% \csgchardef{foo}=5 is the same as \global\chardef\foo=5.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\csgchardef[1]{%
	\expandafter\global\expandafter\chardef\csname#1\endcsname
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Global octet arrays.
%
% \qr@make@array\foo{bar@} defines an array accessor \foo such that
% \foo{idx} expands to \bar@idx where idx is expanded as a number using eTeX's
% \numexpr ... \relax construct.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@make@array[2]{%
	\edef#1##1{%
		\noexpand\csname#2\noexpand\number\noexpand\numexpr##1\relax\noexpand\endcsname
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Array setter.
%
% \qr@array@set\foo{idx}{value} expands idx and value as numbers using eTeX's
% \numexpr ... \relax construct and then globally sets \foo{idx} to value.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@array@set[3]{%
	\global
	\expandafter\expandafter\expandafter
	\chardef#1{#2}=\numexpr#3\relax
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Array unsetter.
%
% \qr@array@unset\foo{idx} undefines \foo{idx}, freeing it from TeX's memory.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@array@unset[2]{%
	\global
	\expandafter\expandafter\expandafter
	\let#1{#2}=\@undefined
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Polynomial view of an array.
%
% View an array as a deg-degree polynomial.
% E.g., view a[0], a[1], ..., a[deg] as
% a[0]x^{deg} + a[1]x^{deg-1} + ... + a[deg-1]
% \qr@polynomial@view\poly{array}{deg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@polynomial@view[3]{%
	\edef#1##1{%
		\noexpand\csname#2\noexpand\number\noexpand\numexpr
			\number\numexpr#3\relax-(##1)\relax
		\noexpand\endcsname
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Implement the GF(256) arithmetic
%
% \gfadd{r}{a}{b}  sets r = a + b
% \gfmul{r}{a}{b}  sets r = a * b
% \gflog{r}{a}     sets r = log_alpha a
% \gfantilog{r}{a} sets r = alpha^a
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand*\qr@xor@bit{%
	\ifodd\qr@gf@a
		\ifodd\qr@gf@b\else
			\advance\qr@gf@r\qr@gf@n
		\fi
	\else
		\ifodd\qr@gf@b
			\advance\qr@gf@r\qr@gf@n
		\fi
	\fi
	\divide\qr@gf@a\tw@
	\divide\qr@gf@b\tw@
	\advance\qr@gf@n\qr@gf@n
}

\newcommand*\gfadd[3]{%
	\qr@gf@a=#2%
	\qr@gf@b=#3%
	\qr@gf@r=\z@
	\qr@gf@n=\@ne
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	#1=\qr@gf@r
}

% Construct the log and antilog tables.
\qr@a=\z@
\qr@b=\@ne
\loop
	\csgchardef{gf@antilog@\number\qr@a}=\qr@b
	\csgchardef{gf@log@\number\qr@b}=\qr@a
	\advance\qr@a\@ne
	% qr@b <- qr@b*2
	\advance\qr@b\qr@b
	% if qr@b > 255 then qr@b <- qr@b (+) 285
	\ifnum\qr@b>\@cclv
		\advance\qr@b-\@cclvi
		\gfadd\qr@b\qr@b{29}%
	\fi
\ifnum\qr@a<\@cclv\repeat
\csgchardef{gf@antilog@255}=\@ne

\newcommand*\gflog[2]{%
	#1=\csuse{gf@log@\number#2}%
}

\newcommand*\gfantilog[2]{%
	#1=\csuse{gf@antilog@\number#2}%
}

\newcommand*\gfmul[3]{%
	\qr@gf@a=#2%
	\qr@gf@b=#3%
	\ifnum\qr@gf@a=\z@
		#1=\z@
	\else \ifnum\qr@gf@b=\z@
		#1=\z@
	\else
		\gflog\qr@gf@a\qr@gf@a
		\gflog\qr@gf@b\qr@gf@b
		\advance\qr@gf@a\qr@gf@b
		\ifnum\qr@gf@a>254
			\advance\qr@gf@a-\@cclv
		\fi
		\gfantilog{#1}\qr@gf@a
	\fi\fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generator polynomials
%
% Given n>0, compute (x + alpha^0) * ... * (x + alpha^{n-1}), setting
% \qr@gen@i to the coefficient of x^i for i in 0, ..., n.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\qr@make@array\qrgen{qr@gen@}

\newcommand*\qrgenpoly[1]{%
	% x + 1
	\qr@array@set\qrgen\z@\@ne
	\qr@a=\z@
	\loop\ifnum#1>\qr@a
		\qr@b=\qr@a
		\advance\qr@b\@ne
		\qr@array@set\qrgen\qr@b\@ne
		\gfantilog\qr@c\qr@a
		{%
		\loop\ifnum\qr@a>\z@
			\gfmul\qr@b{\qr@c}{\qrgen\qr@a}%
			\gfadd\qr@b\qr@b{\qrgen{\qr@a-\@ne}}%
			\qr@array@set\qrgen{\qr@a}\qr@b
			\advance\qr@a\m@ne
		\repeat
		}%
		\gfmul\qr@b{\qrgen\z@}\qr@c
		\qr@array@set\qrgen\z@\qr@b
		\advance\qr@a\@ne
	\repeat
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Polynomial remainder
%
% The divisor must be a monic polynomial.
% \qr@poly@remainder\result\dividend{dividenddeg}\divisor{divisordeg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@poly@remainder[5]{%
	\begingroup
	\let\qr@result#1%
	\let\qr@dividend#2%
	\let\qr@divisor#4%
	% Copy x^{deg(divisor)}dividend to result
	\qr@a=#3\relax
	\qr@b=#5\relax
	\count@=\qr@a
	% for (count@ = deg(dividend); count@ >= 0; --count@)
	%   result[count@ + deg(divisor)] = dividend[count@]
	\loop\ifnum\count@>\m@ne
		\qr@c=\numexpr \count@+\qr@b\relax
		\qr@array@set{\qr@result}{\qr@c}{\qr@dividend{\count@}}%
		\advance\count@\m@ne
	\repeat
	% Set the next deg(divisor) coefficients to 0.
	\count@=\qr@b
	\loop\ifnum\count@>\z@
		\advance\count@\m@ne
		\qr@array@set{\qr@result}{\count@}{\z@}%
	\repeat
	%\qr@dump@poly\qr@result{\qr@a+\qr@b}%
	% Perform the division.
	% for (a=deg(dividend); a >= 0; --a)
	%  c = result[a+deg(divisor)]
	%  for (b=deg(divisor); b >= 0; --b)
	%    result[a + b] = result[a + b] (+) c*divisor[b]
	%  result[a + deg(divisor)] = undefined
	% Since the divisor is monic, when b=deg(divisor), result[a+b]=0 and
	% really, we're going to undefine result[a+b] anyway, so just scip
	% that by moving the --b to the beginning of the inner loop and make
	% the guard >0.
	\loop\ifnum\qr@a>\m@ne
		% We need to protect the inner loop with braces so the inner
		% \repeat does not match the outer \loop. This has the side
		% effect of letting us use \qr@b as a counter since it'll be
		% restore after the loop.
		{%
		\qr@c=\qr@result{\qr@a+\qr@b}%
		%\message{Step \number\qr@a\space Lead coefficient = \number\qr@c^^J}%
		\loop\ifnum\qr@b>\z@
			\advance\qr@b\m@ne
			\gfmul\count@\qr@c{\qr@divisor{\qr@b}}%
			\gfadd\count@\count@{\qr@result{\qr@a+\qr@b}}%
			\qr@array@set{\qr@result}{\qr@a+\qr@b}{\count@}%
		\repeat
		}
		% Undefine the zeroed coefficient.
		%\message{Undefining \number\numexpr\qr@a+\qr@b\relax^^J}%
		\qr@array@unset{\qr@result}{\qr@a+\qr@b}%
		\advance\qr@a\m@ne
		%\qr@dump@poly\qr@result{\qr@a+\qr@b}%
	\repeat
	\endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Iterate over the QR message
%
% Iterate over each token in \qr@str and expand #1 with \qr@token set to the
% token.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@foreach@token[1]{%
	\def\qr@foreach@v{#1}%
	\expandafter\futurelet\expandafter\qr@token\expandafter\qr@foreach\qr@str\qr@foreach
}

\def\qr@foreach{%
	\ifx\qr@token\qr@foreach
		\let\qr@next\@gobble
	\else
		\ifx\qr@token\@sptoken
			\let\qr@next\qr@foreach@space
		\else
			\let\qr@next\qr@foreach@nonspace
		\fi
	\fi
	\qr@next
}

\def\qr@foreach@nonspace#1{%
	\def\qr@token{#1}%
	\qr@foreach@v
	\futurelet\qr@token\qr@foreach
}
% Use the \@xifnch trick (see sources2e) to get a space token in the
% definition of \qr@foreach@space as a delimiter.
\begingroup
\def\:{\qr@foreach@space}
\expandafter\gdef\: {%
	\def\qr@token{ }%
	\qr@foreach@v
	\futurelet\qr@token\qr@foreach
}
\endgroup

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check if a value is in range
%
% \qr@check@range{x}{begin}{end} sets the \ifqr@inrange conditional to true if
% begin <= x <= end.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@check@range[3]{%
	\qr@inrangefalse
	\ifnum#1>#3\else
		\ifnum#1<#2\else
			\qr@inrangetrue
		\fi
	\fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Analyze the QR message
%
% Computes the length of the message and the minimum mode required to encode
% the message. Sets \qr@len and \qr@mode.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@analyze@str{%
	\qr@len=\z@
	\qr@a=\@ne % Numeric.
	\qr@b=\@ne % Alphanumeric.
	\qr@foreach@token{%
		\advance\qr@len\@ne
		\ifnum\qr@b=\@ne
			\qr@c=\expandafter`\qr@token
			\qr@check@range\qr@c{`0}{`9}%
			\ifqr@inrange\else
				\qr@a=\z@
				\qr@check@range\qr@c{`A}{`Z}%
				\ifqr@inrange
				\else\ifnum\qr@c=`\ %
				\else\ifnum\qr@c=`\$%
				\else\ifnum\qr@c=`\%%
				\else\ifnum\qr@c=`\*%
				\else\ifnum\qr@c=`\+%
				\else\ifnum\qr@c=`\-%
				\else\ifnum\qr@c=`\.%
				\else\ifnum\qr@c=`\/%
				\else\ifnum\qr@c=`\:%
				\else
					\qr@b=\z@
				\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
			\fi
		\fi
	}%
	\ifnum\qr@a=\@ne
		\def\qr@mode{numeric}%
	\else\ifnum\qr@b=\@ne
		\def\qr@mode{alphanum}%
	\else
		\def\qr@mode{byte}%
	\fi\fi
	\message{String length: \number\qr@len^^J}%
	\message{QR mode: \qr@mode^^J}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Set the QR parameters.
%
% Sets the QR version (which controls the number of "modules" per row and
% column) as well as internal parameters:
%   \qr@total@data@words  total number of data codewords
%   \qr@ecc@codewords     number of ECC codewords per block
%   \qr@blks@per@groupi   number of blocks in group 1
%   \qr@words@per@blki    number of data codwords per block in group 1
%   \qr@blks@per@groupii  number of blocks in group 2
%   \qr@blks@per@groupii  number of data codewords per block in group 2
%   \qr@total@blks        total number of blocks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@set@parameters{%
	% Based on the error correction and length, pick the smallest QR
	% version for byte mode.
	\if L\qr@ecl
		\def\qr@v##1 ##2 ##3 ##4 ##5.{\ifnum\qr@len<##2 \chardef\qr@ver=##1\relax\fi}%
		\def\qr@next##1##2##3##4{\qr@next##1.}%
	\else \if M\qr@ecl
		\def\qr@v##1 ##2 ##3 ##4 ##5.{\ifnum\qr@len<##3 \chardef\qr@ver=##1\relax\fi}%
		\def\qr@next##1##2##3##4{\qr@next##2.}%
	\else \if Q\qr@ecl
		\def\qr@v##1 ##2 ##3 ##4 ##5.{\ifnum\qr@len<##4 \chardef\qr@ver=##1\relax\fi}%
		\def\qr@next##1##2##3##4{\qr@next##3.}%
	\else \if H\qr@ecl
		\def\qr@v##1 ##2 ##3 ##4 ##5.{\ifnum\qr@len<##5 \chardef\qr@ver=##1\relax\fi}%
		\def\qr@next##1##2##3##4{\qr@next##4.}%
	\else
		\PackageError{qr}{Invalid error correction parameter.}
			{Valid values are L, M, Q, and H}%
	\fi\fi\fi\fi
	\chardef\qr@ver=\z@
	% Pick the appropriate version for the mode.
	\csname qr@select@version@\qr@mode @mode\endcsname
	\ifnum\qr@ver=\z@
		\PackageError{qr}{String is too long for given error
			correction level}{}%
	\fi
	% Set the other parameters.
	\let\qr@v\qr@next
	\def\qr@next##1 ##2 ##3 ##4.{%
		\chardef\qr@total@data@words=##1\relax
		\chardef\qr@ecc@codewords=##2\relax
		\chardef\qr@blks@per@groupi=##3\relax
		\chardef\qr@words@per@blki=##4\relax
	}%
	\message{QR version: \number\qr@ver-\qr@ecl^^J}%
	\ifcase\qr@ver
	\or\qr@v{19 7 1 19}{16 10 1 16}{13 13 1 13}{9 17 1 9}% 1
	\or\qr@v{34 10 1 34}{28 16 1 28}{22 22 1 22}{16 28 1 16}% 2
	\or\qr@v{55 15 1 55}{44 26 1 44}{34 18 2 17}{26 22 2 13}% 3
	\or\qr@v{80 20 1 80}{64 18 2 32}{48 26 2 24}{36 16 4 9}% 4
	\or\qr@v{108 26 1 108}{86 24 2 43}{62 18 2 15}{46 22 2 11}% 5
	\or\qr@v{136 18 2 68}{108 16 4 27}{76 24 4 19}{60 28 4 15}% 6
	\or\qr@v{156 20 2 78}{124 18 4 31}{88 18 2 14}{66 26 4 13}% 7
	\or\qr@v{194 24 2 97}{154 22 2 38}{110 22 4 18}{86 26 4 14}% 8
	\or\qr@v{232 30 2 116}{182 22 3 36}{132 20 4 16}{100 24 4 12}% 9
	\or\qr@v{274 18 2 68}{216 26 4 43}{154 24 6 19}{122 28 6 15}% 10
	\or\qr@v{324 20 4 81}{254 30 1 50}{180 28 4 22}{140 24 3 12}% 11
	\or\qr@v{370 24 2 92}{290 22 6 36}{206 26 4 20}{158 28 7 14}% 12
	\or\qr@v{428 26 4 107}{334 22 8 37}{244 24 8 20}{180 22 12 11}% 13
	\or\qr@v{461 30 3 115}{365 24 4 40}{261 20 11 16}{197 24 11 12}% 14
	\or\qr@v{523 22 5 87}{415 24 5 41}{295 30 5 24}{223 24 11 12}% 15
	\or\qr@v{589 24 5 98}{453 28 7 45}{325 24 15 19}{253 30 3 15}% 16
	\or\qr@v{647 28 1 107}{507 28 10 46}{367 28 1 22}{283 28 2 14}% 17
	\or\qr@v{721 30 5 120}{563 26 9 43}{397 28 17 22}{313 28 2 14}% 18
	\or\qr@v{795 28 3 113}{627 26 3 44}{445 26 17 21}{341 26 9 13}% 19
	\or\qr@v{861 28 3 107}{669 26 3 41}{485 30 15 24}{385 28 15 15}% 20
	\or\qr@v{932 28 4 116}{714 26 17 42}{512 28 17 22}{406 30 19 16}% 21
	\or\qr@v{1006 28 2 111}{782 28 17 46}{568 30 7 24}{442 24 34 13}% 22
	\or\qr@v{1094 30 4 121}{860 28 4 47}{614 30 11 24}{464 30 16 15}% 23
	\or\qr@v{1174 30 6 117}{914 28 6 45}{664 30 11 24}{514 30 30 16}% 24
	\or\qr@v{1276 26 8 106}{1000 28 8 47}{718 30 7 24}{538 30 22 15}% 25
	\or\qr@v{1370 28 10 114}{1062 28 19 46}{754 28 28 22}{596 30 33 16}% 26
	\or\qr@v{1468 30 8 122}{1128 28 22 45}{808 30 8 23}{628 30 12 15}% 27
	\or\qr@v{1531 30 3 117}{1193 28 3 45}{871 30 4 24}{661 30 11 15}% 28
	\or\qr@v{1631 30 7 116}{1267 28 21 45}{911 30 1 23}{701 30 19 15}% 29
	\or\qr@v{1735 30 5 115}{1373 28 19 47}{985 30 15 24}{745 30 23 15}% 30
	\or\qr@v{1843 30 13 115}{1455 28 2 46}{1033 30 42 24}{793 30 23 15}% 31
	\or\qr@v{1955 30 17 115}{1541 28 10 46}{1115 30 10 24}{845 30 19 15}% 32
	\or\qr@v{2071 30 17 115}{1631 28 14 46}{1171 30 29 24}{901 30 11 15}% 33
	\or\qr@v{2191 30 13 115}{1725 28 14 46}{1231 30 44 24}{961 30 59 16}% 34
	\or\qr@v{2306 30 12 121}{1812 28 12 47}{1286 30 39 24}{986 30 22 15}% 35
	\or\qr@v{2434 30 6 121}{1914 28 6 47}{1354 30 46 24}{1054 30 2 15}% 36
	\or\qr@v{2566 30 17 122}{1992 28 29 46}{1426 30 49 24}{1096 30 24 15}% 37
	\or\qr@v{2702 30 4 122}{2102 28 13 46}{1502 30 48 24}{1142 30 42 15}% 38
	\or\qr@v{2812 30 20 117}{2216 28 40 47}{1582 30 43 24}{1222 30 10 15}% 39
	\or\qr@v{2956 30 19 118}{2334 28 18 47}{1666 30 34 24}{1276 30 20 15}% 40
	\fi
	% Compute the group 2 parameters.
	\qr@a=\numexpr \qr@total@data@words-\qr@blks@per@groupi*\qr@words@per@blki \relax
	\ifnum\qr@a>\z@
		\chardef\qr@words@per@blkii=\numexpr\qr@words@per@blki+\@ne\relax
		\divide\qr@a\qr@words@per@blkii
		\chardef\qr@blks@per@groupii=\qr@a
	\else
		\chardef\qr@blks@per@groupii=\z@
		\chardef\qr@words@per@blkii=\z@
	\fi
	\chardef\qr@total@blks=\numexpr\qr@blks@per@groupi+\qr@blks@per@groupii\relax
	\dbg\qr@total@data@words
	\dbg\qr@ecc@codewords
	\dbg\qr@blks@per@groupi
	\dbg\qr@words@per@blki
	\dbg\qr@blks@per@groupii
	\dbg\qr@words@per@blkii
	\dbg\qr@total@blks
	\qr@reset@data@ptr
}
\newcommand*\dbg[1]{\message{\string#1=\number#1^^J}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% QR message encoding
%
% The QR message is encoded based on the mode and length as a string of bits
% (including padding bits) and then broken into 8-bit codewords (and padding
% codewords are appended to the total size). The codewords are then broken
% into blocks and groups.
%
% Any given (data) codeword can be referenced by a triple (group, block,
% index). We maintain a pointer to the next codeword to be encoded by keeping
% track of \qr@grp, \qr@blk, and \qr@idx as well as some additional
% bookkeeping \qr@blks@per@group and \qr@words@per@blk as those values are
% dependant on \qr@grp.
%
% \qr@grp is set to 3 once the pointer has advanced through all (data)
% codewords.
%
% The error correction codewords are computed based on each block so a similar
% pointer isn't as useful.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Reset the data pointer.
\def\qr@reset@data@ptr{%
	\global\chardef\qr@grp=\@ne
	\global\chardef\qr@blk=\z@
	\global\qr@idx=\z@
	\global\chardef\qr@blks@per@group=\qr@blks@per@groupi
	\global\chardef\qr@words@per@blk=\qr@words@per@blki
}

% Advance the data pointer by 1, updating all components of the triple as
% necessary.
\def\qr@advance@data@ptr{%
	\ifnum\qr@grp=\thr@@
		\PackageError{qr}{Internal error
			\string\qr@advance@data@ptr}{}
	\fi
	\global\advance\qr@idx\@ne
	\ifnum\qr@idx=\qr@words@per@blk
		% Move to next block.
		\global\qr@idx=\z@
		\count@=\numexpr\qr@blk+\@ne\relax
		\global\chardef\qr@blk=\count@
		\ifnum\qr@blk=\qr@blks@per@group
			% Move to next group.
			\global\chardef\qr@blk=\z@
			\ifnum\qr@grp=\@ne
				\ifnum\qr@words@per@blkii>\z@
					\global\chardef\qr@grp=\tw@
					\global\chardef\qr@blks@per@group=\qr@blks@per@groupii
					\global\chardef\qr@words@per@blk=\qr@words@per@blkii
				\else
					\global\chardef\qr@grp=\thr@@
					\global\chardef\qr@words@per@blk=\z@
					\global\chardef\qr@blks@per@group=\z@
				\fi
			\else
				\global\chardef\qr@grp=\thr@@
				\global\chardef\qr@words@per@blk=\z@
				\global\chardef\qr@blks@per@group=\z@
			\fi
		\fi
	\fi
}

% Write the codeword at the current pointer and increment the pointer.
\newcommand*\qr@append@word[1]{%
	\message{\number\qr@grp.\number\qr@blk.\number\qr@idx=\number#1^^J}%
	\csgchardef{qr@msg@\number\qr@grp.\number\qr@blk.\number\qr@idx}=#1\relax
	\qr@advance@data@ptr
}

% \qr@pow{x} is expandable to 2^x for x in 0, 1, ..., 16.
\newcommand*\qr@pow[1]{%
	\ifcase\numexpr#1\relax\@ne
	\or\tw@
	\or4
	\or8
	\or\sixt@@n
	\or\@xxxii
	\or64
	\or128
	\or\@cclvi
	\or512
	\or1024
	\or2048
	\or4096
	\or8192
	\or16384
	\or32768
	\or65536
	\else\PackageError{qr}{Power too large}{}%
	\fi
}

% QR messages are encoded as bits. The encoding depends on the mode and each
% mode produces differt numbers of bits at a time. The interface to the
% low-level encoding is \qr@encode@bits. Once more than 8 bits have been
% encoded, they are stored as the next code word using \qr@append@word.
%
% The API for this is pretty hackish. Three count registers are used for the
% process and cannot be used for anything else while encoding is happening.
%   #1        The number of bits to encode.
%   \qr@a     Holds the bits that have been encoded, but not stored.
%   \qr@b     On input, the bits to encode; set to 0 at the end.
%   \qr@c     The number of bits encoded (in \qr@a) but not stored.
%   \qr@gf@a  The total number of bits encoded.
% \qr@b can be used as desired before and after \qr@encode@bits (but must be
% set to the appropriate value to encode before, of course) but the other
% three must not be used (or restored if used).
\newcommand*\qr@encode@bits[1]{%
	% a = (a << bits) + b
	\qr@a=\numexpr\qr@a*\qr@pow{#1}+\qr@b\relax
	\advance\qr@gf@a#1\relax
	\advance\qr@c#1\relax
	\qr@encode@bits@store
	\qr@b=\z@
}

% While \qr@c >= 8, store a codeword.
\def\qr@encode@bits@store{%
	\ifnum\qr@c>7
		\qr@b=\qr@a
		\divide\qr@b\qr@pow{\qr@c-8}%
		\qr@append@word\qr@b
		\qr@a=\numexpr\qr@a-\qr@pow{\qr@c-8}*\qr@b\relax
		\advance\qr@c-8
		\expandafter\qr@encode@bits@store
	\fi
}

% Encode the numeric mode.
\newcommand*\qr@encode@numeric@mode{%
	\qr@b=\@ne % Numeric mode.
	\qr@encode@bits{4}%
	% Add number count.
	\qr@b=\qr@len
	\ifnum\qr@ver<10
		\qr@encode@bits{10}%
	\else\ifnum\qr@ver<27
		\qr@encode@bits{12}%
	\else
		\qr@encode@bits{14}%
	\fi\fi
	% Encode numbers three at a time.
	\count@=\z@
	\qr@foreach@token{%
		\qr@b=\numexpr10*\qr@b+\qr@token\relax
		\advance\count@\@ne
		\ifnum\count@=\thr@@
			\qr@encode@bits{10}%
			\count@=\z@
		\fi
	}%
	% Encode any remaining numbers.
	\ifcase\count@
	\or\qr@encode@bits{4}%
	\or\qr@encode@bits{7}%
	\fi
}

% Encode the (misnamed) alphanumeric mode.
\newcommand*\qr@encode@alphanum@mode{%
	\qr@b=\tw@ % Alphanumeric mode.
	\qr@encode@bits{4}%
	% Add character count.
	\qr@b=\qr@len
	\ifnum\qr@ver<10
		\qr@encode@bits{9}%
	\else\ifnum\qr@ver<27
		\qr@encode@bits{11}%
	\else
		\qr@encode@bits{13}%
	\fi\fi
	% Encode characters two at a time.
	\count@=\z@
	\qr@foreach@token{%
		\qr@gf@b=\expandafter`\qr@token
		\qr@check@range\qr@gf@b{`0}{`9}%
		\multiply\qr@b45
		\ifqr@inrange
			\advance\qr@b\qr@token\relax
		\else
			\qr@check@range\qr@gf@b{`A}{`Z}%
			\ifqr@inrange\advance\qr@b\numexpr\qr@gf@b-55\relax
			\else\ifnum\qr@gf@b=`\ \advance\qr@b36
			\else\ifnum\qr@gf@b=`\$\advance\qr@b37
			\else\ifnum\qr@gf@b=`\%\advance\qr@b38
			\else\ifnum\qr@gf@b=`\*\advance\qr@b39
			\else\ifnum\qr@gf@b=`\+\advance\qr@b40
			\else\ifnum\qr@gf@b=`\-\advance\qr@b41
			\else\ifnum\qr@gf@b=`\.\advance\qr@b42
			\else\ifnum\qr@gf@b=`\/\advance\qr@b43
			\else                  \advance\qr@b44 % colon
			\fi\fi\fi\fi\fi\fi\fi\fi\fi
		\fi
		\advance\count@\@ne
		\ifnum\count@=\tw@
			\qr@encode@bits{11}%
			\count@=\z@
		\fi
	}%
	% Encode the final character, if length is odd.
	\ifnum\count@=\@ne
		\qr@encode@bits{6}%
	\fi
}

% Encode byte mode.
\newcommand*\qr@encode@byte@mode{%
	\qr@b=4 % Byte mode.
	\qr@encode@bits{4}%
	% Encode character count.
	\qr@b=\qr@len
	\ifnum\qr@ver<10
		\qr@encode@bits{8}%
	\else
		\qr@encode@bits{16}%
	\fi
	% Encode bytes.
	\qr@foreach@token{%
		% Get the ASCII value.
		\qr@b=\expandafter`\qr@token
		\qr@encode@bits{8}%
	}%
}

% Encode the QR message based on the mode. \qr@a, \qr@b, \qr@c, and \qr@gf@a
% are used as described above. Up to four padding bits are added, then
% additional padding bits are added to bring the total up to a multiple of 8.
% Finally, add padding codewords (alternating 236 and 17).
\newcommand*\qr@encode@str{%
	\qr@gf@a=\z@ % Total bits encoded.
	\qr@a=\z@    % Encoded but not stored bits.
	\qr@c=\z@    % Number of bits encoded (in \qr@a) but not stored.
	% Encode the string based on the mode.
	\csname qr@encode@\qr@mode @mode\endcsname
	% Compute number of bits remaining.
	\count@=\numexpr8*\qr@total@data@words-\qr@gf@a\relax
	% Encode min(4,count@) 0 bits.
	\qr@b=\z@
	\ifnum\count@>4
		\qr@encode@bits{4}%
	\else
		\qr@encode@bits\count@
	\fi
	% Encode enough bits to get to a multiple of 8.
	\ifnum\qr@c>\z@
		\count@=\numexpr8-\qr@c\relax
		\qr@encode@bits\count@
	\fi
	% Now add padding words.
	% Number of words of padding (we can use eTeX's rounding division
	% because qr@gf@a is a multiple of 8 due to the final zero encodings
	% above).
	\qr@a=\numexpr\qr@total@data@words-\qr@gf@a/8\relax
	% Append 236 and 17 until the full size has been reached.
	\loop\ifnum\qr@a>\@ne
		\qr@append@word{236}%
		\qr@append@word{17}%
		\advance\qr@a-2
	\repeat
	\ifnum\qr@a>\z@
		\qr@append@word{236}%
	\fi
}

% Debugging.
\newcommand\qr@dump@array[2]{%
	\begingroup
	\edef\qr@arr{#1}%
	\message{Dumping array \qr@arr:^^J}%
	\qr@b=#2\relax
	\qr@a=\z@
	\loop\ifnum\qr@a<\qr@b
		\message{\qr@arr\number\qr@a=\number\csname\qr@arr\number\qr@a\endcsname^^J}%
		\advance\qr@a\@ne
	\repeat
	\endgroup
}

% Debugging.
\newcommand*\qr@dump@poly[2]{%
	\begingroup
	\qr@a=\numexpr#2\relax
	\message{\string#1=(}%
	\loop\ifnum\qr@a>\z@
		\message{\number#1{\qr@a}, }%
		\advance\qr@a\m@ne
	\repeat
	\message{\number#1{\z@})^^J}%
	\endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compute error correcting code
%
% Compute the Reed--Solomon error correcting code for each block. Simply treat
% each block as the coefficients of a polynomial (using \qr@polynomial@view)
% and compute the polynomial remainder of division by the generator polynomial
% over GF(256).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@compute@ecc{%
	% Construct the generator polynomial.
	\qrgenpoly\qr@ecc@codewords
	% Compute the ECC for each block in group 1.
	% b = degree of msg polynomial
	\qr@b=\numexpr\qr@words@per@blki-\@ne\relax
	\qr@a=\z@
	\loop\ifnum\qr@a<\qr@blks@per@groupi
		\qr@polynomial@view\qr@result{qr@ecc@1.\number\qr@a.}{\qr@ecc@codewords-\@ne}%
		\qr@polynomial@view\qr@divisor{qr@msg@1.\number\qr@a.}\qr@b
		\qr@poly@remainder
			\qr@result
			\qr@divisor\qr@b
			\qrgen\qr@ecc@codewords
		\qr@dump@array{qr@ecc@1.\number\qr@a.}\qr@ecc@codewords
		\advance\qr@a\@ne
	\repeat
	% Compute the ECC for each block in group 2.
	\qr@a=\z@
	\qr@b=\numexpr\qr@words@per@blkii-\@ne\relax
	\loop\ifnum\qr@a<\qr@blks@per@groupii
		\qr@polynomial@view\qr@result{qr@ecc@2.\number\qr@a.}{\qr@ecc@codewords-\@ne}%
		\qr@polynomial@view\qr@divisor{qr@msg@2.\number\qr@a.}\qr@b
		\qr@poly@remainder
			\qr@result
			\qr@divisor\qr@b
			\qrgen\qr@ecc@codewords
		\qr@dump@array{qr@ecc@2.\number\qr@a.}\qr@ecc@codewords
		\advance\qr@a\@ne
	\repeat
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Interleaved view of codewords
%
% This can be used to access the idx-th msg or ecc codeword.
% \qr@interleave{arr}{wordsPerBlki}{idx}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@interleave[3]{%
	% Compute the column first.
	\csname#1\expandafter\qr@interleave@column\expandafter
		{\number\qr@div{#3}\qr@total@blks}{#2}{#3}%
	\endcsname
}

% \qr@interleave@column{column}{wordsPerBlki}{idx}
\def\qr@interleave@column#1#2#3{%
	% The block number is idx-column*total@blks.
	\expandafter\qr@interleave@blk\expandafter
		{\number\numexpr#3-#1*\qr@total@blks}{#1}{#2}{#3}%
}

% \qr@interleave@blk{block}{column}{wordsPerBlki}{idx}
\def\qr@interleave@blk#1#2#3#4{%
	\ifnum#2=\numexpr#3\relax
		% This must be the final column and since the column number is
		% the number of words per block in group 1, this must be in
		% group 2. Thus the block number is actually block.
		2.#1.#2%
	\else
		% Either this is not the final column or all groups have the
		% same number of words per block.
		\ifnum#1<\qr@blks@per@groupi
			% Group 1.
			1.#1.#2%
		\else
			% Group 2.
			2.\number\numexpr#1-\qr@blks@per@groupi\relax.#2%
		\fi
	\fi
}

% eTeX's \numexpr ... \relax rounds division! Compensate for that.
\def\qr@div#1#2{%
	\ifnum\numexpr(#1)/(#2)*(#2)\relax>\numexpr#1\relax
		\expandafter\@firstoftwo
	\else
		\expandafter\@secondoftwo
	\fi
	{\numexpr(#1)/(#2)-\@ne\relax}%
	{\numexpr(#1)/(#2)\relax}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create a QR code block
%
% \qrcodeblock{width}{version}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qrcodeblock[2]{%
	\chardef\qr@ver=\numexpr#2\relax
	\chardef\qr@modules=\numexpr\qr@ver*4+17\relax
	\setlength\qr@width{\dimexpr(#1)/\qr@modules\relax}%
	\qr@zero@modules
	\qr@add@function@patterns
	\leavevmode
	\vbox{%
		\offinterlineskip
		\setbox\z@=\hb@xt@\qr@width{\vbox to\qr@width{\vss}\hss}%
		\setbox\@ne=\hb@xt@\qr@width{\vrule\@width\qr@width\@height\qr@width}%
		\setbox\tw@=\copy\z@
		\setbox\thr@@=\copy\@ne
		\setbox254=\hbox{\textcolor{gray}{\vrule\@width\qr@width\@height\qr@width}}%
		\iftrue
		\setbox4=\vbox to\z@{\vss\hrule\@width#1}%
		\setbox5=\hb@xt@\z@{\hss\vrule\@height\qr@width}%
		\else
		\setbox4=\copy\voidb@x
		\setbox5=\copy\voidb@x
		\fi
		\ifvoid4 \else\copy4 \fi
		\qr@a=\z@
		\loop\ifnum\qr@a<\qr@modules
			\hbox{%
				\ifvoid5 \else\copy5 \fi
				\qr@b=\z@
				\loop\ifnum\qr@b<\qr@modules
					\copy\qr@module\qr@a\qr@b
					\ifvoid5 \else\copy5 \fi
					\advance\qr@b\@ne
				\repeat
			}%
			\advance\qr@a\@ne
			\ifvoid4 \else\copy4 \fi
		\repeat
	}%
}

\def\qr@module#1#2{%
	\csname qr@m@\number\numexpr#1\relax.\number\numexpr#2\relax\endcsname
}

\def\qr@module@set#1#2#3{%
	\global\expandafter\chardef
	\csname qr@m@\number\numexpr#1\relax.\number\numexpr#2\relax\endcsname=\numexpr#3\relax
}%

\chardef\qr@white=\z@
\chardef\qr@black=\@ne
\chardef\qr@function@white=\tw@
\chardef\qr@function@black=\thr@@

\def\qr@zero@modules{%
	\qr@a=\z@
	\qr@b=\z@
	\loop\ifnum\qr@a<\qr@modules
		{%
		\loop\ifnum\qr@b<\qr@modules
			\qr@module@set\qr@a\qr@b{254}%
			\advance\qr@b\@ne
		\repeat
		}%
		\advance\qr@a\@ne
	\repeat
}

% Generic addition of modules starting at (\qr@gf@a, \qr@gf@b) and updated
% according to \qr@v. Modules end with \relax.
\def\qr@add@generic#1{%
	\ifx\relax#1\else
		\qr@module@set{\qr@gf@a}{\qr@gf@b}{#1}%
		\qr@v
		\expandafter\qr@add@generic
	\fi
}


% Add row, increment \qr@gf@a afterword.
\def\qr@add@row#1{%
	\begingroup
	\def\qr@v{\advance\qr@gf@b\@ne}%
	\qr@add@generic#1\relax
	\endgroup
	\advance\qr@gf@a\@ne
}

\def\qr@add@row@at#1#2{%
	\qr@gf@a=\numexpr#1\relax
	\qr@gf@b=\numexpr#2\relax
	\qr@add@row
}

% Add col, increment \qr@gf@b afterword.
\def\qr@add@col#1{%
	\begingroup
	\def\qr@v{\advance\qr@gf@a\@ne}%
	\qr@add@generic#1\relax
	\endgroup
	\advance\qr@gf@b\@ne
}

\def\qr@add@col@at#1#2{%
	\qr@gf@a=\numexpr#1\relax
	\qr@gf@b=\numexpr#2\relax
	\qr@add@col
}

% Add a finder pattern with separators.
\def\qr@add@finder#1#2{%
	\qr@add@row@at{#1}{#2}{3333333}%
	\qr@add@row{3222223}%
	\qr@add@row{3233323}%
	\qr@add@row{3233323}%
	\qr@add@row{3233323}%
	\qr@add@row{3222223}%
	\qr@add@row{3333333}%
	% Add separators.
	\ifnum\qr@gf@a=7 % Top left or right, so add below.
		\qr@add@row{2222222}%
		\ifnum\qr@gf@b=\z@ % Top left.
			\qr@add@col@at{\z@}{7}{22222222}%
		\else % Top right.
			\qr@add@col@at{\z@}{\qr@gf@b-\@ne}{22222222}%
		\fi
	\else % Bottom left.
		\qr@add@row@at{(#1)-\@ne}{\z@}{22222222}%
		\qr@add@col@at{\qr@gf@a}{7}{2222222}%
	\fi
}

\def\qr@alignment@row{\afterassignment\qr@alignment@rowx\qr@gf@a=}
\def\qr@alignment@rowx{%
	\ifnum\qr@gf@a>\z@
		\advance\qr@gf@a-\tw@
		\qr@alignment@col\qr@alignments\z@
		\expandafter\qr@alignment@row
	\fi
}

\def\qr@alignment@col{\afterassignment\qr@alignment@colx\qr@gf@b=}%
\def\qr@alignment@colx{%
	\ifnum\qr@gf@b>\z@
		\advance\qr@gf@b-\tw@
		\ifnum\qr@module{\qr@gf@a}{\qr@gf@b}>10 %<\tw@
		\ifnum\qr@module{\qr@gf@a+5}{\qr@gf@b}>10 %<\tw@
		\ifnum\qr@module{\qr@gf@a}{\qr@gf@b+5}>10 %<\tw@
			\qr@add@row{33333}%
			\qr@add@row{32223}%
			\qr@add@row{32323}%
			\qr@add@row{32223}%
			\qr@add@row{33333}%
			\advance\qr@gf@a-5
		\fi\fi\fi
		\expandafter\qr@alignment@col
	\fi
}

\def\qr@add@timing{%
	\qr@a=8
	\qr@b=\numexpr\qr@modules-8\relax
	\loop\ifnum\qr@a<\qr@b
		\ifodd\qr@a
			\qr@module@set{\qr@a}{6}{\qr@function@white}%
			\qr@module@set{6}{\qr@a}{\qr@function@white}%
		\else
			\qr@module@set{\qr@a}{6}{\qr@function@black}%
			\qr@module@set{6}{\qr@a}{\qr@function@black}%
		\fi
		\advance\qr@a\@ne
	\repeat
}

% Add reserved space for format and version information as well as the dark
% module.
\def\qr@add@reserved{%
	% Add format reserved spaces.
	% Top left. Write the timing module to black.
	\qr@add@row@at{8}{\z@}{222222322}%
	\qr@add@col@at{\z@}{8}{22222232}%
	% Top right.
	\qr@add@row@at{8}{\qr@modules-8}{22222222}%
	% Bottom left. Include the dark module.
	\qr@add@col@at{\qr@modules-8}{8}{32222222}%
	% Add version reserved spaces for versions larger than 6.
	\ifnum\qr@ver>6
		\qr@add@row@at{\qr@modules-11}{\z@}{222222}%
		\qr@add@row{222222}%
		\qr@add@row{222222}%
		\qr@add@col@at{\z@}{\qr@modules-11}{222222}%
		\qr@add@col{222222}%
		\qr@add@col{222222}%
	\fi
}

% Add function patterns and separators
\def\qr@add@function@patterns{%
	%% Add Finder patterns and separators
	\qr@add@finder\z@\z@
	\qr@add@finder{\qr@ver*4+10}\z@
	\qr@add@finder\z@{\qr@ver*4+10}%
	% Add alignment patterns.
	\qr@set@alignments
	\qr@alignment@row\qr@alignments\z@
	%% Add timing patterns.
	\qr@add@timing
	%% Add format place holders (and dark module).
	\qr@add@reserved
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create a QR code
%
% \qrcode[errorcorrection]{width}{str}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\qrcode[3][Q]{%
	\edef\qr@ecl{#1}%
	\setlength\qr@width{#2}%
	\edef\qr@str{\detokenize{#3}}%
	\qr@analyze@str
	\qr@set@parameters
	\qr@encode@str
	\qr@compute@ecc
	%\qrdumpdata
	\qrdumpinterleaveddata
}

% Debugging.
\newcommand*\qrdumpdata{%
	\qr@reset@data@ptr
	\loop\ifnum\qr@grp<\thr@@
		\number\csname qr@msg@\number\qr@grp.\number\qr@blk.\number\qr@idx\endcsname
		\qr@advance@data@ptr
		\
	\repeat
}

% Debugging.
\newcommand*\qrdumpinterleaveddata{%
	\message{Interleaved data:^^J}%
	\qr@idx=\z@
	\loop\ifnum\qr@idx<\qr@total@data@words
		\message{\number\qr@interleave{qr@msg@}\qr@words@per@blki\qr@idx, }%
		\advance\qr@idx\@ne
	\repeat
	\message{^^JInterleaved ecc:^^J}%
	\qr@idx=\z@
	\loop\ifnum\qr@idx<\qr@total@data@words
		\message{\number\qr@interleave{qr@ecc@}\qr@words@per@blki\qr@idx, }%
		\advance\qr@idx\@ne
	\repeat
	\message{^^J}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Table-generated code for QR version
%
% Select the minimal QR version for the mode based on the error correction
% level. \qr@v is defined to compare \qr@len to the appropriate parameter
% (based on the correction level) and if \qr@len is smaller, set \qr@ver to
% the first parameter.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\qr@select@version@numeric@mode{%
	\qr@v 40 7090 5597 3994 3058.%
	\qr@v 39 6744 5314 3792 2928.%
	\qr@v 38 6480 5040 3600 2736.%
	\qr@v 37 6154 4776 3418 2626.%
	\qr@v 36 5837 4589 3245 2525.%
	\qr@v 35 5530 4344 3082 2362.%
	\qr@v 34 5254 4135 2950 2302.%
	\qr@v 33 4966 3910 2806 2158.%
	\qr@v 32 4687 3694 2671 2023.%
	\qr@v 31 4418 3487 2474 1898.%
	\qr@v 30 4159 3290 2359 1783.%
	\qr@v 29 3910 3036 2182 1678.%
	\qr@v 28 3670 2858 2086 1582.%
	\qr@v 27 3518 2702 1934 1502.%
	\qr@v 26 3284 2545 1805 1426.%
	\qr@v 25 3058 2396 1719 1287.%
	\qr@v 24 2813 2189 1589 1229.%
	\qr@v 23 2621 2060 1469 1109.%
	\qr@v 22 2410 1873 1359 1057.%
	\qr@v 21 2233 1709 1225 970.%
	\qr@v 20 2062 1601 1160 920.%
	\qr@v 19 1904 1501 1064 814.%
	\qr@v 18 1726 1347 949 747.%
	\qr@v 17 1549 1213 877 675.%
	\qr@v 16 1409 1083 776 603.%
	\qr@v 15 1251 992 704 531.%
	\qr@v 14 1102 872 622 469.%
	\qr@v 13 1023 797 581 428.%
	\qr@v 12 884 692 490 375.%
	\qr@v 11 773 605 428 332.%
	\qr@v 10 653 514 365 289.%
	\qr@v 9 553 433 313 236.%
	\qr@v 8 462 366 260 203.%
	\qr@v 7 371 294 208 155.%
	\qr@v 6 323 256 179 140.%
	\qr@v 5 256 203 145 107.%
	\qr@v 4 188 150 112 83.%
	\qr@v 3 128 102 78 59.%
	\qr@v 2 78 64 49 35.%
	\qr@v 1 42 35 28 18.%
}

\def\qr@select@version@alphanum@mode{%
	\qr@v 40 4297 3392 2421 1853.%
	\qr@v 39 4088 3221 2299 1775.%
	\qr@v 38 3928 3055 2182 1659.%
	\qr@v 37 3730 2895 2072 1592.%
	\qr@v 36 3538 2781 1967 1531.%
	\qr@v 35 3352 2633 1868 1432.%
	\qr@v 34 3184 2507 1788 1395.%
	\qr@v 33 3010 2370 1701 1308.%
	\qr@v 32 2841 2239 1619 1227.%
	\qr@v 31 2678 2114 1500 1151.%
	\qr@v 30 2521 1995 1430 1081.%
	\qr@v 29 2370 1840 1323 1017.%
	\qr@v 28 2224 1733 1264 959.%
	\qr@v 27 2133 1638 1173 911.%
	\qr@v 26 1991 1543 1095 865.%
	\qr@v 25 1854 1452 1042 780.%
	\qr@v 24 1705 1327 964 745.%
	\qr@v 23 1589 1249 891 673.%
	\qr@v 22 1461 1135 824 641.%
	\qr@v 21 1353 1036 743 588.%
	\qr@v 20 1250 971 703 558.%
	\qr@v 19 1154 910 645 494.%
	\qr@v 18 1047 817 575 453.%
	\qr@v 17 939 735 532 409.%
	\qr@v 16 855 657 471 366.%
	\qr@v 15 759 601 427 322.%
	\qr@v 14 668 529 377 284.%
	\qr@v 13 620 484 353 260.%
	\qr@v 12 536 420 297 228.%
	\qr@v 11 469 367 260 201.%
	\qr@v 10 396 312 222 175.%
	\qr@v 9 336 263 190 144.%
	\qr@v 8 280 222 158 123.%
	\qr@v 7 225 179 126 94.%
	\qr@v 6 196 155 109 85.%
	\qr@v 5 155 123 88 65.%
	\qr@v 4 115 91 68 51.%
	\qr@v 3 78 62 48 36.%
	\qr@v 2 48 39 30 21.%
	\qr@v 1 26 21 17 11.%
}

\def\qr@select@version@byte@mode{%
	\qr@v 40 2954 2332 1664 1274.%
	\qr@v 39 2810 2214 1580 1220.%
	\qr@v 38 2700 2100 1500 1140.%
	\qr@v 37 2564 1990 1424 1094.%
	\qr@v 36 2432 1912 1352 1052.%
	\qr@v 35 2304 1810 1284 984.%
	\qr@v 34 2189 1723 1229 959.%
	\qr@v 33 2069 1629 1169 899.%
	\qr@v 32 1953 1539 1113 843.%
	\qr@v 31 1841 1453 1031 791.%
	\qr@v 30 1733 1371 983 743.%
	\qr@v 29 1629 1265 909 699.%
	\qr@v 28 1529 1191 869 659.%
	\qr@v 27 1466 1126 806 626.%
	\qr@v 26 1368 1060 752 594.%
	\qr@v 25 1274 998 716 536.%
	\qr@v 24 1172 912 662 512.%
	\qr@v 23 1092 858 612 462.%
	\qr@v 22 1004 780 566 440.%
	\qr@v 21 930 712 510 404.%
	\qr@v 20 859 667 483 383.%
	\qr@v 19 793 625 443 339.%
	\qr@v 18 719 561 395 311.%
	\qr@v 17 645 505 365 281.%
	\qr@v 16 587 451 323 251.%
	\qr@v 15 521 413 293 221.%
	\qr@v 14 459 363 259 195.%
	\qr@v 13 426 332 242 178.%
	\qr@v 12 368 288 204 156.%
	\qr@v 11 322 252 178 138.%
	\qr@v 10 272 214 152 120.%
	\qr@v 9 231 181 131 99.%
	\qr@v 8 193 153 109 85.%
	\qr@v 7 155 123 87 65.%
	\qr@v 6 135 107 75 59.%
	\qr@v 5 107 85 61 45.%
	\qr@v 4 79 63 47 35.%
	\qr@v 3 54 43 33 25.%
	\qr@v 2 33 27 21 15.%
	\qr@v 1 18 15 12 8.%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Table-generated alignment mark cordinates.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\qr@set@alignments{%
	\edef\qr@alignments{%
		\ifcase\qr@ver
		\or  % 1
		\or 6 18 % 2
		\or 6 22 % 3
		\or 6 26 % 4
		\or 6 30 % 5
		\or 6 34 % 6
		\or 6 22 38 % 7
		\or 6 24 42 % 8
		\or 6 26 46 % 9
		\or 6 28 50 % 10
		\or 6 30 54 % 11
		\or 6 32 58 % 12
		\or 6 34 62 % 13
		\or 6 26 46 66 % 14
		\or 6 26 48 70 % 15
		\or 6 26 50 74 % 16
		\or 6 30 54 78 % 17
		\or 6 30 56 82 % 18
		\or 6 30 58 86 % 19
		\or 6 34 62 90 % 20
		\or 6 28 50 72 94 % 21
		\or 6 26 50 74 98 % 22
		\or 6 30 54 78 102 % 23
		\or 6 28 54 80 106 % 24
		\or 6 32 58 84 110 % 25
		\or 6 30 58 86 114 % 26
		\or 6 34 62 90 118 % 27
		\or 6 26 50 74 98 122 % 28
		\or 6 30 54 78 102 126 % 29
		\or 6 26 52 78 104 130 % 30
		\or 6 30 56 82 108 134 % 31
		\or 6 34 60 86 112 138 % 32
		\or 6 30 58 86 114 142 % 33
		\or 6 34 62 90 118 146 % 34
		\or 6 30 54 78 102 126 150 % 35
		\or 6 24 50 76 102 128 154 % 36
		\or 6 28 54 80 106 132 158 % 37
		\or 6 32 58 84 110 136 162 % 38
		\or 6 26 54 82 110 138 166 % 39
		\or 6 30 58 86 114 142 170 % 40
		\fi
	}%
}
