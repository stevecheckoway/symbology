\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{qr}
  [2016/04/20 v1.0 Construct QR codes]

\RequirePackage{etoolbox}
\RequirePackage{xkeyval}
\AtBeginDocument{\RequirePackage{xcolor}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check if a value is in range
%
% \qr@check@range{x}{begin}{end} sets the \ifqr@inrange conditional to true if
% begin <= x <= end.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@check@range[3]{%
	\qr@inrangefalse
	\ifnum#1>#3\else
		\ifnum#1<#2\else
			\qr@inrangetrue
		\fi
	\fi
}
\newif\ifqr@inrange

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Options.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\qr@star{*}
\newcommand*\qr@star@or@range[3]{%
	\ifx#1\qr@star
		\qr@inrangetrue
	\else
		\qr@check@range{#1}{#2}{#3}%
	\fi
}

% Common options.
\define@cmdkeys{qr}[qr@]{width,overlap,darkcolor,lightcolor,quietcolor}
\let\KV@qr@height=\KV@qr@width % Alias.
\define@cmdkey{qr}[qr@requested@]{version}{%
	\qr@star@or@range\qr@requested@version\@ne{40}%
	\ifqr@inrange\else
		\PackageError{qr}{Requested version `#1' invalid.\MessageBreak
				Valid values: 1-40 or *}{}%
	\fi
}
\define@choicekey+{qr}{mode}[\qr@requested@mode\qr@requested@mode@nr]{numeric,alphanum,byte,*}{}
	{\PackageError{qr}{Requested mode `#1' invalid.\MessageBreak
			   Valid values: numeric, alphanum, byte, or *}{}}
\define@choicekey+{qr}{level}[\qr@requested@ecl\qr@requested@ecl@nr]{*,L,M,Q,H}{}
	{\PackageError{qr}{Requested error correction level `#1' invalid.\MessageBreak
	                   Valid values: L, M, Q, H, or *}{}}
\define@boolkey{qr}[qr@]{quietzone}[true]{}

% Uncommon options.
\define@cmdkey{qr}[qr@requested@]{mask}{%
	\qr@star@or@range\qr@requested@mask\z@7%
	\ifqr@inrange\else
		\PackageError{qr}{Requested mask `#1' invalid.\MessageBreak
				Valid values: 0-7 or *}{}%
	\fi
}
\define@boolkey{qr}[qr@]{strictlevel}[true]{}

% Debugging options.
\def\qr@set@debugging{%
	\let\ifqr@dbg@data=\ifqr@dbg@all
	\let\ifqr@dbg@ecc=\ifqr@dbg@all
	\let\ifqr@dbg@interleave=\ifqr@dbg@all
}
\define@boolkeys{qr@dbg}[qr@dbg@]{data,ecc,interleave,timing,parameters}[true]
\define@boolkey{qr@dbg}[qr@dbg@]{all}[true]{\qr@set@debugging}
\define@key{qr}{debug}{\setkeys{qr@dbg}{#1}}

\savekeys{qr}{darkcolor,lightcolor}
% Initial key values. Don't use \presetkeys since they will override package
% keys.
\setkeys{qr}{width=2cm,overlap=.5pt,version=*,mode=*,level=*,mask=*,
             darkcolor=.,lightcolor=white}
\presetkeys{qr}{}{quietcolor=\usevalue{lightcolor}}

% Package options.
\ProcessOptionsX<qr>\relax
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcount\qr@gf@a
\newcount\qr@gf@b
\newcount\qr@gf@r
\newcount\qr@gf@n
\newcount\qr@a
\newcount\qr@b
\newcount\qr@c
\newcount\qr@idx

% Nesting loops without groups. Braces are needed around the body.
% \qr@while\ifnum\a<\b{%
%	body including other loops!
% }\qr@repeat
% Or a do-while loop.
% \qr@while{%
%	body including other loops!
%}\ifnum\a<\b\qr@repeat
\newcount\qr@loop@depth
\let\qr@repeat\fi
\def\qr@while#1#{\qr@whilex{#1}}
\long\def\qr@whilex#1#2#3\qr@repeat{%
	\global\advance\qr@loop@depth\@ne
	\long\csxdef{qr@loop@body@\number\qr@loop@depth}{%
		\unexpanded{#1\relax #2#3\relax}%
		\noexpand\expandafter\expandafter\noexpand
		\csname qr@loop@body@\number\qr@loop@depth\endcsname
		\noexpand\fi
	}%
	\csname qr@loop@body@\number\qr@loop@depth\endcsname
	\global\csundef{qr@loop@body@\number\qr@loop@depth}%
	\global\advance\qr@loop@depth\m@ne
}

\def\qr@for#1=#2to#3by#4#{\qr@forx{#1}{#2}{#3}{#4}}
\long\def\qr@forx#1#2#3#4#5{%
	\global\advance\qr@loop@depth\@ne
	\long\csxdef{qr@loop@body@\number\qr@loop@depth}{%
		\noexpand\ifnum\number\numexpr#3\relax
		\ifnum\numexpr#4\relax>\z@>\else<\fi\noexpand#1%
		\unexpanded{#5}%
		\advance\noexpand#1\number\numexpr#4\relax\relax
		\noexpand\expandafter\expandafter\noexpand
		\csname qr@loop@body@\number\qr@loop@depth\endcsname
		\noexpand\fi
	}%
	#1=\numexpr#2\relax
	\csname qr@loop@body@\number\qr@loop@depth\endcsname
	\global\csundef{qr@loop@body@\number\qr@loop@depth}%
	\global\advance\qr@loop@depth\m@ne
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Global \chardef of a control sequence.
%
% \csgchardef{foo}=5 is the same as \global\chardef\foo=5.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\csgchardef[1]{%
	\expandafter\global\expandafter\chardef\csname#1\endcsname
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Global octet arrays.
%
% \qr@make@array\foo{bar@} defines an array accessor \foo such that
% \foo{idx} expands to \bar@idx where idx is expanded as a number using eTeX's
% \numexpr ... \relax construct.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@make@array[2]{%
	\edef#1##1{%
		\noexpand\csname#2\noexpand\number\numexpr##1\relax\endcsname
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Array setter.
%
% \qr@array@set\foo{idx}{value} expands idx and value as numbers using eTeX's
% \numexpr ... \relax construct and then globally sets \foo{idx} to value.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@array@set[3]{%
	\global\expandafter\expandafter\expandafter
	\chardef#1{#2}=\numexpr#3\relax
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Array unsetter.
%
% \qr@array@unset\foo{idx} undefines \foo{idx}, freeing it from TeX's memory.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@array@unset[2]{%
	\global\expandafter\expandafter\expandafter
	\let#1{#2}=\@undefined
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Global octet matrices.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@make@matrix[2]{%
	\edef#1##1##2{%
		\noexpand\csname#2\noexpand\number\numexpr##1\relax
		.\noexpand\number\numexpr##2\relax\noexpand\endcsname
	}%
}

\newcommand*\qr@matrix@set[4]{%
	\global\expandafter\expandafter\expandafter
	\chardef#1{#2}{#3}=\numexpr#4\relax
}

\newcommand*\qr@matrix@unset[3]{%
	\global\expandafter\expandafter\expandafter
	\let#1{#2}{#3}=\@undefined
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Polynomial view of an array.
%
% View an array as a deg-degree polynomial.
% E.g., view a[0], a[1], ..., a[deg] as
% a[0]x^{deg} + a[1]x^{deg-1} + ... + a[deg-1]
% \qr@polynomial@view\poly{array}{deg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@polynomial@view[3]{%
	\edef#1##1{%
		\noexpand\csname#2\noexpand\number\noexpand\numexpr
			\number\numexpr#3\relax-(##1)\relax
		\noexpand\endcsname
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Implement the GF(256) arithmetic
%
% \gfadd{r}{a}{b}  sets r = a + b
% \gfmul{r}{a}{b}  sets r = a * b
% r=\gflog{a}     sets r = log_alpha a
% r=\gfantilog{a} sets r = alpha^a
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand*\qr@xor@bit{%
	\ifodd\qr@gf@a
		\ifodd\qr@gf@b\else
			\advance\qr@gf@r\qr@gf@n
		\fi
	\else
		\ifodd\qr@gf@b
			\advance\qr@gf@r\qr@gf@n
		\fi
	\fi
	\divide\qr@gf@a\tw@
	\divide\qr@gf@b\tw@
	\advance\qr@gf@n\qr@gf@n
}

\newcommand*\gfadd[3]{%
	\qr@gf@a=#2%
	\qr@gf@b=#3%
	\qr@gf@r=\z@
	\qr@gf@n=\@ne
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	\qr@xor@bit
	#1=\qr@gf@r
}

% Construct the log and antilog tables.
\qr@a=\z@
\qr@b=\@ne
\loop
	\csgchardef{gf@antilog@\number\qr@a}=\qr@b
	\csgchardef{gf@log@\number\qr@b}=\qr@a
	\advance\qr@a\@ne
	% qr@b <- qr@b*2
	\advance\qr@b\qr@b
	% if qr@b > 255 then qr@b <- qr@b (+) 285
	\ifnum\qr@b>\@cclv
		\advance\qr@b-\@cclvi
		\gfadd\qr@b\qr@b{29}%
	\fi
\ifnum\qr@a<\@cclv\repeat
\csgchardef{gf@antilog@255}=\@ne

\newcommand*\gflog[1]{%
	\csname gf@log@\number#1\endcsname
}

\newcommand*\gfantilog[1]{%
	\csname gf@antilog@\number#1\endcsname
}

\newcommand*\gfmul[3]{%
	\qr@gf@a=#2%
	\qr@gf@b=#3%
	\ifnum\qr@gf@a=\z@
		#1=\z@
	\else \ifnum\qr@gf@b=\z@
		#1=\z@
	\else
		\qr@gf@a=\gflog\qr@gf@a
		\qr@gf@b=\gflog\qr@gf@b
		\advance\qr@gf@a\qr@gf@b
		\ifnum\qr@gf@a>254
			\advance\qr@gf@a-\@cclv
		\fi
		#1=\gfantilog\qr@gf@a
	\fi\fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generator polynomials
%
% Given n>0, compute (x + alpha^0) * ... * (x + alpha^{n-1}), setting
% \qr@gen@i to the coefficient of x^i for i in 0, ..., n.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\qr@make@array\qrgen{qr@gen@}

\newcommand*\qrgenpoly[1]{%
	% x + 1
	\qr@array@set\qrgen\z@\@ne
	\qr@for \qr@a=\z@ to#1by\@ne{%
		\qr@b=\qr@a
		\advance\qr@b\@ne
		\qr@array@set\qrgen\qr@b\@ne
		\qr@c=\gfantilog\qr@a
		\chardef\qr@save=\qr@a % Avoid the group by saving \qr@a.
		\qr@for \qr@a=\qr@a to\z@ by\m@ne{%
			\gfmul\qr@b{\qr@c}{\qrgen\qr@a}%
			\gfadd\qr@b\qr@b{\qrgen{\qr@a-\@ne}}%
			\qr@array@set\qrgen{\qr@a}\qr@b
		}%
		\qr@a=\qr@save % Restore \qr@a.
		\gfmul\qr@b{\qrgen\z@}\qr@c
		\qr@array@set\qrgen\z@\qr@b
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Polynomial remainder
%
% The divisor must be a monic polynomial.
% \qr@poly@remainder\result\dividend{dividenddeg}\divisor{divisordeg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@poly@remainder[5]{%
	\begingroup
	\let\qr@result#1%
	\let\qr@dividend#2%
	\let\qr@divisor#4%
	% Copy x^{deg(divisor)}dividend to result
	\qr@a=#3\relax
	\qr@b=#5\relax
	% for (count@ = deg(dividend); count@ >= 0; --count@)
	%   result[count@ + deg(divisor)] = dividend[count@]
	\qr@for \count@=\qr@a to\m@ne by\m@ne{%
		\qr@c=\numexpr \count@+\qr@b\relax
		\qr@array@set{\qr@result}{\qr@c}{\qr@dividend{\count@}}%
	}%
	% Set the next deg(divisor) coefficients to 0.
	\qr@for \count@=\qr@b-1 to\m@ne by\m@ne{%
		\qr@array@set{\qr@result}{\count@}{\z@}%
	}%
	%\qr@dump@poly\qr@result{\qr@a+\qr@b}%
	% Perform the division.
	% for (a=deg(dividend); a >= 0; --a)
	%  c = result[a+deg(divisor)]
	%  for (b=deg(divisor); b >= 0; --b)
	%    result[a + b] = result[a + b] (+) c*divisor[b]
	%  result[a + deg(divisor)] = undefined
	% Since the divisor is monic, when b=deg(divisor), result[a+b]=0 and
	% really, we're going to undefine result[a+b] anyway, so just skip
	% that.
	\qr@for \qr@a=\qr@a to\m@ne by\m@ne{%
		\qr@c=\qr@result{\qr@a+\qr@b}%
		\chardef\qr@save=\qr@b % Save \qr@b to avoid the group.
		\qr@for \qr@b=\qr@b-\@ne to\m@ne by\m@ne{%
			\gfmul\count@\qr@c{\qr@divisor{\qr@b}}%
			\gfadd\count@\count@{\qr@result{\qr@a+\qr@b}}%
			\qr@array@set{\qr@result}{\qr@a+\qr@b}{\count@}%
		}%
		\qr@b=\qr@save
		% Undefine the zeroed coefficient.
		\qr@array@unset{\qr@result}{\qr@a+\qr@b}%
	}
	\endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Iterate over the QR message
%
% Iterate over each token in \qr@msg and expand #1 with \qr@token set to the
% token.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@foreach@token[1]{%
	\def\qr@foreach@v{#1}%
	\expandafter\futurelet\expandafter\qr@token\expandafter\qr@foreach\qr@msg\qr@foreach
}

\def\qr@foreach{%
	\ifx\qr@token\qr@foreach
		\let\qr@gf@next\@gobble
	\else
		\ifx\qr@token\@sptoken
			\let\qr@gf@next\qr@foreach@space
		\else
			\let\qr@gf@next\qr@foreach@nonspace
		\fi
	\fi
	\qr@gf@next
}

\def\qr@foreach@nonspace#1{%
	\def\qr@token{#1}%
	\qr@foreach@v
	\futurelet\qr@token\qr@foreach
}
% Use the \@xifnch trick (see sources2e) to get a space token in the
% definition of \qr@foreach@space as a delimiter.
\begingroup
\def\:{\qr@foreach@space}
\expandafter\gdef\: {%
	\def\qr@token{ }%
	\qr@foreach@v
	\futurelet\qr@token\qr@foreach
}
\endgroup

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Analyze the QR message
%
% Computes the length of the message and the minimum mode required to encode
% the message. Sets \qr@len and \qr@mode.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@analyze@msg{%
	\qr@gf@n=\z@
	\qr@a=\@ne % Numeric.
	\qr@b=\@ne % Alphanumeric.
	\qr@foreach@token{%
		\advance\qr@gf@n\@ne
		\ifnum\qr@b=\@ne
			\qr@c=\expandafter`\qr@token
			\qr@check@range\qr@c{`0}{`9}%
			\ifqr@inrange\else
				\qr@a=\z@
				\qr@check@range\qr@c{`A}{`Z}%
				\ifqr@inrange
				\else\ifnum\qr@c=`\ %
				\else\ifnum\qr@c=`\$%
				\else\ifnum\qr@c=`\%%
				\else\ifnum\qr@c=`\*%
				\else\ifnum\qr@c=`\+%
				\else\ifnum\qr@c=`\-%
				\else\ifnum\qr@c=`\.%
				\else\ifnum\qr@c=`\/%
				\else\ifnum\qr@c=`\:%
				\else
					\qr@b=\z@
				\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
			\fi
		\fi
	}%
	\chardef\qr@len=\qr@gf@n
	\ifnum\qr@a=\@ne
		\def\qr@mode{numeric}%
		\qr@a=\z@
	\else\ifnum\qr@b=\@ne
		\def\qr@mode{alphanum}%
		\qr@a=\@ne
	\else
		\def\qr@mode{byte}%
		\qr@a=\tw@
	\fi\fi
	% If the requested mode is less than the minimum mode, it's an error.
	\ifx\qr@requested@mode\qr@star\else
	\ifnum\qr@requested@mode@nr<\qr@a
		\PackageError{qr}{Requested mode `\qr@requested@mode'
			not sufficient to encode data.\MessageBreak
			Mode `\qr@mode' or high necessary}{}%
	\else
		\let\qr@mode=\qr@requested@mode
	\fi\fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Select version.
%
% Select the minimum version that supports the given error correction level,
% length, and mode.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\qr@version@for@L#1 #2 #3 #4 #5.{\ifnum\qr@len<#2 \chardef\qr@ver=#1\relax\fi}%
\def\qr@version@for@M#1 #2 #3 #4 #5.{\ifnum\qr@len<#3 \chardef\qr@ver=#1\relax\fi}%
\def\qr@version@for@Q#1 #2 #3 #4 #5.{\ifnum\qr@len<#4 \chardef\qr@ver=#1\relax\fi}%
\def\qr@version@for@H#1 #2 #3 #4 #5.{\ifnum\qr@len<#5 \chardef\qr@ver=#1\relax\fi}%
\def\qr@version@for@ecl#1{%
	\edef\qr@ecl{#1}%
	\letcs\qr@v{qr@version@for@\qr@ecl}%
	\csname qr@select@version@\qr@mode @mode\endcsname
}

\def\qr@ecl@in@range#1#2{%
	% if a <= #1 && #1 <= b,
	\ifnum\qr@a>#1\else
	\ifnum#1>\qr@b\else
		\def\qr@ecl{#2}%
	\fi\fi
}
\def\qr@ecl@for@version@#1 #2 #3 #4 #5.{%
	\ifnum#1=\qr@ver
		\ifnum\qr@len<#2\relax \qr@ecl@in@range1L\fi
		\ifnum\qr@len<#3\relax \qr@ecl@in@range2M\fi
		\ifnum\qr@len<#4\relax \qr@ecl@in@range3Q\fi
		\ifnum\qr@len<#5\relax \qr@ecl@in@range4H\fi
	\fi
}
\def\qr@ecl@for@version{%
	\let\qr@v=\qr@ecl@for@version@
	\csname qr@select@version@\qr@mode @mode\endcsname
}

\newcommand*\qr@select@version{%
	% Pick the appropriate version and ecl for the mode.
	\chardef\qr@ver=\z@
	\let\qr@ecl=\relax
	\qr@a=\qr@requested@ecl@nr\relax % Minimum ecl.
	\qr@b=4 % Maximum ecl.
	\ifx\qr@requested@version\qr@star
		% Version not requested, take the minimum version for the ecl.
		\ifx\qr@requested@ecl\qr@star
			% Ecl not requested, try M, the "standard" level, per
			% Annex I. If M is too high, try L.
			\qr@version@for@ecl M
			\ifnum\qr@ver=\z@
				\qr@version@for@ecl L
			\else
				% Look for a higher ecl for the same version.
				\qr@ecl@for@version
			\fi
		\else
			% Ecl requested.
			\qr@version@for@ecl \qr@requested@ecl
			\ifqr@strictlevel\else
				\qr@ecl@for@version
			\fi
		\fi
	\else
		% Version requested.
		\chardef\qr@ver=\qr@requested@version\relax
		% If requested@ecl != * and strictlevel, be strict.
		\ifx\qr@requested@ecl\qr@star\else
		\ifqr@strictlevel
				\qr@b=\qr@a
		\fi\fi
		\qr@ecl@for@version
	\fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Set the QR parameters.
%
% Sets internal parameters based on the version and error correction level.
%   \qr@total@data@words  total number of data codewords
%   \qr@total@ecc@words   total number of ECC codewords
%   \qr@ecc@words@per@blk number of ECC codewords per block
%   \qr@blks@per@groupi   number of blocks in group 1
%   \qr@words@per@blki    number of data codwords per block in group 1
%   \qr@blks@per@groupii  number of blocks in group 2
%   \qr@blks@per@groupii  number of data codewords per block in group 2
%   \qr@total@blks        total number of blocks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@set@parameters{%
	\if L\qr@ecl
		\def\qr@v##1##2##3##4{\qr@gf@next##1.}%
	\else \if M\qr@ecl
		\def\qr@v##1##2##3##4{\qr@gf@next##2.}%
	\else \if Q\qr@ecl
		\def\qr@v##1##2##3##4{\qr@gf@next##3.}%
	\else \if H\qr@ecl
		\def\qr@v##1##2##3##4{\qr@gf@next##4.}%
	\else
		\PackageError{qr}{Invalid error correction parameter}
			{Valid values are L, M, Q, and H}%
	\fi\fi\fi\fi
	\def\qr@gf@next##1 ##2 ##3 ##4.{%
		\mathchardef\qr@total@data@words=##1\relax
		\chardef\qr@ecc@words@per@blk=##2\relax
		\chardef\qr@blks@per@groupi=##3\relax
		\chardef\qr@words@per@blki=##4\relax
	}%
	\ifcase\qr@ver
	\or\qr@v{19 7 1 19}{16 10 1 16}{13 13 1 13}{9 17 1 9}% 1
	\or\qr@v{34 10 1 34}{28 16 1 28}{22 22 1 22}{16 28 1 16}% 2
	\or\qr@v{55 15 1 55}{44 26 1 44}{34 18 2 17}{26 22 2 13}% 3
	\or\qr@v{80 20 1 80}{64 18 2 32}{48 26 2 24}{36 16 4 9}% 4
	\or\qr@v{108 26 1 108}{86 24 2 43}{62 18 2 15}{46 22 2 11}% 5
	\or\qr@v{136 18 2 68}{108 16 4 27}{76 24 4 19}{60 28 4 15}% 6
	\or\qr@v{156 20 2 78}{124 18 4 31}{88 18 2 14}{66 26 4 13}% 7
	\or\qr@v{194 24 2 97}{154 22 2 38}{110 22 4 18}{86 26 4 14}% 8
	\or\qr@v{232 30 2 116}{182 22 3 36}{132 20 4 16}{100 24 4 12}% 9
	\or\qr@v{274 18 2 68}{216 26 4 43}{154 24 6 19}{122 28 6 15}% 10
	\or\qr@v{324 20 4 81}{254 30 1 50}{180 28 4 22}{140 24 3 12}% 11
	\or\qr@v{370 24 2 92}{290 22 6 36}{206 26 4 20}{158 28 7 14}% 12
	\or\qr@v{428 26 4 107}{334 22 8 37}{244 24 8 20}{180 22 12 11}% 13
	\or\qr@v{461 30 3 115}{365 24 4 40}{261 20 11 16}{197 24 11 12}% 14
	\or\qr@v{523 22 5 87}{415 24 5 41}{295 30 5 24}{223 24 11 12}% 15
	\or\qr@v{589 24 5 98}{453 28 7 45}{325 24 15 19}{253 30 3 15}% 16
	\or\qr@v{647 28 1 107}{507 28 10 46}{367 28 1 22}{283 28 2 14}% 17
	\or\qr@v{721 30 5 120}{563 26 9 43}{397 28 17 22}{313 28 2 14}% 18
	\or\qr@v{795 28 3 113}{627 26 3 44}{445 26 17 21}{341 26 9 13}% 19
	\or\qr@v{861 28 3 107}{669 26 3 41}{485 30 15 24}{385 28 15 15}% 20
	\or\qr@v{932 28 4 116}{714 26 17 42}{512 28 17 22}{406 30 19 16}% 21
	\or\qr@v{1006 28 2 111}{782 28 17 46}{568 30 7 24}{442 24 34 13}% 22
	\or\qr@v{1094 30 4 121}{860 28 4 47}{614 30 11 24}{464 30 16 15}% 23
	\or\qr@v{1174 30 6 117}{914 28 6 45}{664 30 11 24}{514 30 30 16}% 24
	\or\qr@v{1276 26 8 106}{1000 28 8 47}{718 30 7 24}{538 30 22 15}% 25
	\or\qr@v{1370 28 10 114}{1062 28 19 46}{754 28 28 22}{596 30 33 16}% 26
	\or\qr@v{1468 30 8 122}{1128 28 22 45}{808 30 8 23}{628 30 12 15}% 27
	\or\qr@v{1531 30 3 117}{1193 28 3 45}{871 30 4 24}{661 30 11 15}% 28
	\or\qr@v{1631 30 7 116}{1267 28 21 45}{911 30 1 23}{701 30 19 15}% 29
	\or\qr@v{1735 30 5 115}{1373 28 19 47}{985 30 15 24}{745 30 23 15}% 30
	\or\qr@v{1843 30 13 115}{1455 28 2 46}{1033 30 42 24}{793 30 23 15}% 31
	\or\qr@v{1955 30 17 115}{1541 28 10 46}{1115 30 10 24}{845 30 19 15}% 32
	\or\qr@v{2071 30 17 115}{1631 28 14 46}{1171 30 29 24}{901 30 11 15}% 33
	\or\qr@v{2191 30 13 115}{1725 28 14 46}{1231 30 44 24}{961 30 59 16}% 34
	\or\qr@v{2306 30 12 121}{1812 28 12 47}{1286 30 39 24}{986 30 22 15}% 35
	\or\qr@v{2434 30 6 121}{1914 28 6 47}{1354 30 46 24}{1054 30 2 15}% 36
	\or\qr@v{2566 30 17 122}{1992 28 29 46}{1426 30 49 24}{1096 30 24 15}% 37
	\or\qr@v{2702 30 4 122}{2102 28 13 46}{1502 30 48 24}{1142 30 42 15}% 38
	\or\qr@v{2812 30 20 117}{2216 28 40 47}{1582 30 43 24}{1222 30 10 15}% 39
	\or\qr@v{2956 30 19 118}{2334 28 18 47}{1666 30 34 24}{1276 30 20 15}% 40
	\fi
	% Compute the group 2 parameters.
	\qr@a=\numexpr \qr@total@data@words-\qr@blks@per@groupi*\qr@words@per@blki \relax
	\ifnum\qr@a>\z@
		\chardef\qr@words@per@blkii=\numexpr\qr@words@per@blki+\@ne\relax
		\divide\qr@a\qr@words@per@blkii
		\chardef\qr@blks@per@groupii=\qr@a
	\else
		\chardef\qr@blks@per@groupii=\z@
		\chardef\qr@words@per@blkii=\z@
	\fi
	\chardef\qr@total@blks=\numexpr\qr@blks@per@groupi+\qr@blks@per@groupii\relax
	\mathchardef\qr@total@ecc@words=\numexpr\qr@total@blks*\qr@ecc@words@per@blk\relax
	\qr@reset@data@ptr
	\ifqr@dbg@parameters
		\qr@dbg\qr@total@data@words
		\qr@dbg\qr@total@ecc@words
		\qr@dbg\qr@ecc@words@per@blk
		\qr@dbg\qr@blks@per@groupi
		\qr@dbg\qr@words@per@blki
		\qr@dbg\qr@blks@per@groupii
		\qr@dbg\qr@words@per@blkii
		\qr@dbg\qr@total@blks
	\fi
}
\newcommand*\qr@dbg[1]{\message{\string#1=\number#1^^J}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% QR message encoding
%
% The QR message is encoded based on the mode and length as a string of bits
% (including padding bits) and then broken into 8-bit codewords (and padding
% codewords are appended to the total size). The codewords are then broken
% into blocks and groups.
%
% Any given (data) codeword can be referenced by a triple (group, block,
% index). We maintain a pointer to the next codeword to be encoded by keeping
% track of \qr@grp, \qr@blk, and \qr@idx as well as some additional
% bookkeeping \qr@blks@per@group and \qr@words@per@blk as those values are
% dependant on \qr@grp.
%
% \qr@grp is set to 3 once the pointer has advanced through all (data)
% codewords.
%
% The error correction codewords are computed based on each block so a similar
% pointer isn't as useful.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Reset the data pointer.
\def\qr@reset@data@ptr{%
	\global\chardef\qr@grp=\@ne
	\global\chardef\qr@blk=\z@
	\global\qr@idx=\z@
	\global\chardef\qr@blks@per@group=\qr@blks@per@groupi
	\global\chardef\qr@words@per@blk=\qr@words@per@blki
}

% Advance the data pointer by 1, updating all components of the triple as
% necessary.
\def\qr@advance@data@ptr{%
	\ifnum\qr@grp=\thr@@
		\PackageError{qr}{Internal error
			\string\qr@advance@data@ptr}{}
	\fi
	\global\advance\qr@idx\@ne
	\ifnum\qr@idx=\qr@words@per@blk
		% Move to next block.
		\global\qr@idx=\z@
		\count@=\numexpr\qr@blk+\@ne\relax
		\global\chardef\qr@blk=\count@
		\ifnum\qr@blk=\qr@blks@per@group
			% Move to next group.
			\global\chardef\qr@blk=\z@
			\ifnum\qr@grp=\@ne
				\ifnum\qr@words@per@blkii>\z@
					\global\chardef\qr@grp=\tw@
					\global\chardef\qr@blks@per@group=\qr@blks@per@groupii
					\global\chardef\qr@words@per@blk=\qr@words@per@blkii
				\else
					\global\chardef\qr@grp=\thr@@
					\global\chardef\qr@words@per@blk=\z@
					\global\chardef\qr@blks@per@group=\z@
				\fi
			\else
				\global\chardef\qr@grp=\thr@@
				\global\chardef\qr@words@per@blk=\z@
				\global\chardef\qr@blks@per@group=\z@
			\fi
		\fi
	\fi
}

% Write the codeword at the current pointer and increment the pointer.
\newcommand*\qr@append@word[1]{%
	%\message{\number\qr@grp.\number\qr@blk.\number\qr@idx=\number#1^^J}%
	\csgchardef{qr@msg@\number\qr@grp.\number\qr@blk.\number\qr@idx}=#1\relax
	\qr@advance@data@ptr
}

% \qr@pow{x} is expandable to 2^x for x in 0, 1, ..., 16.
\newcommand*\qr@pow[1]{%
	\ifcase\numexpr#1\relax\@ne
	\or\tw@
	\or4
	\or8
	\or\sixt@@n
	\or\@xxxii
	\or64
	\or128
	\or\@cclvi
	\or512
	\or1024
	\or2048
	\or4096
	\or8192
	\or16384
	\or32768
	\or65536
	\else\PackageError{qr}{Power too large}{}%
	\fi
}

% QR messages are encoded as bits. The encoding depends on the mode and each
% mode produces differt numbers of bits at a time. The interface to the
% low-level encoding is \qr@encode@bits. Once more than 8 bits have been
% encoded, they are stored as the next code word using \qr@append@word.
%
% The API for this is pretty hackish. Three count registers are used for the
% process and cannot be used for anything else while encoding is happening.
%   #1        The number of bits to encode.
%   \qr@a     Holds the bits that have been encoded, but not stored.
%   \qr@b     On input, the bits to encode; set to 0 at the end.
%   \qr@c     The number of bits encoded (in \qr@a) but not stored.
%   \qr@gf@a  The total number of bits encoded.
% \qr@b can be used as desired before and after \qr@encode@bits (but must be
% set to the appropriate value to encode before, of course) but the other
% three must not be used (or restored if used).
\newcommand*\qr@encode@bits[1]{%
	% a = (a << bits) + b
	\qr@a=\numexpr\qr@a*\qr@pow{#1}+\qr@b\relax
	\advance\qr@gf@a#1\relax
	\advance\qr@c#1\relax
	\qr@encode@bits@store
	\qr@b=\z@
}

% While \qr@c >= 8, store a codeword.
\def\qr@encode@bits@store{%
	\ifnum\qr@c>7
		\qr@b=\qr@a
		\divide\qr@b\qr@pow{\qr@c-8}%
		\qr@append@word\qr@b
		\qr@a=\numexpr\qr@a-\qr@pow{\qr@c-8}*\qr@b\relax
		\advance\qr@c-8
		\expandafter\qr@encode@bits@store
	\fi
}

% Encode the numeric mode.
\newcommand*\qr@encode@numeric@mode{%
	\qr@b=\@ne % Numeric mode.
	\qr@encode@bits{4}%
	% Add number count.
	\qr@b=\qr@len
	\ifnum\qr@ver<10
		\qr@encode@bits{10}%
	\else\ifnum\qr@ver<27
		\qr@encode@bits{12}%
	\else
		\qr@encode@bits{14}%
	\fi\fi
	% Encode numbers three at a time.
	\count@=\z@
	\qr@foreach@token{%
		\qr@b=\numexpr10*\qr@b+\qr@token\relax
		\advance\count@\@ne
		\ifnum\count@=\thr@@
			\qr@encode@bits{10}%
			\count@=\z@
		\fi
	}%
	% Encode any remaining numbers.
	\ifcase\count@
	\or\qr@encode@bits{4}%
	\or\qr@encode@bits{7}%
	\fi
}

% Encode the (misnamed) alphanumeric mode.
\newcommand*\qr@encode@alphanum@mode{%
	\qr@b=\tw@ % Alphanumeric mode.
	\qr@encode@bits{4}%
	% Add character count.
	\qr@b=\qr@len
	\ifnum\qr@ver<10
		\qr@encode@bits{9}%
	\else\ifnum\qr@ver<27
		\qr@encode@bits{11}%
	\else
		\qr@encode@bits{13}%
	\fi\fi
	% Encode characters two at a time.
	\count@=\z@
	\qr@foreach@token{%
		\qr@gf@b=\expandafter`\qr@token
		\qr@check@range\qr@gf@b{`0}{`9}%
		\multiply\qr@b45
		\ifqr@inrange
			\advance\qr@b\qr@token\relax
		\else
			\qr@check@range\qr@gf@b{`A}{`Z}%
			\ifqr@inrange\advance\qr@b\numexpr\qr@gf@b-55\relax
			\else\ifnum\qr@gf@b=`\ \advance\qr@b36
			\else\ifnum\qr@gf@b=`\$\advance\qr@b37
			\else\ifnum\qr@gf@b=`\%\advance\qr@b38
			\else\ifnum\qr@gf@b=`\*\advance\qr@b39
			\else\ifnum\qr@gf@b=`\+\advance\qr@b40
			\else\ifnum\qr@gf@b=`\-\advance\qr@b41
			\else\ifnum\qr@gf@b=`\.\advance\qr@b42
			\else\ifnum\qr@gf@b=`\/\advance\qr@b43
			\else                  \advance\qr@b44 % colon
			\fi\fi\fi\fi\fi\fi\fi\fi\fi
		\fi
		\advance\count@\@ne
		\ifnum\count@=\tw@
			\qr@encode@bits{11}%
			\count@=\z@
		\fi
	}%
	% Encode the final character, if length is odd.
	\ifnum\count@=\@ne
		\qr@encode@bits{6}%
	\fi
}

% Encode byte mode.
\newcommand*\qr@encode@byte@mode{%
	\qr@b=4 % Byte mode.
	\qr@encode@bits{4}%
	% Encode character count.
	\qr@b=\qr@len
	\ifnum\qr@ver<10
		\qr@encode@bits{8}%
	\else
		\qr@encode@bits{16}%
	\fi
	% Encode bytes.
	\qr@foreach@token{%
		% Get the ASCII value.
		\qr@b=\expandafter`\qr@token
		\qr@encode@bits{8}%
	}%
}

% Encode the QR message based on the mode. \qr@a, \qr@b, \qr@c, and \qr@gf@a
% are used as described above. Up to four padding bits are added, then
% additional padding bits are added to bring the total up to a multiple of 8.
% Finally, add padding codewords (alternating 236 and 17).
\newcommand*\qr@encode@msg{%
	\qr@gf@a=\z@ % Total bits encoded.
	\qr@a=\z@    % Encoded but not stored bits.
	\qr@c=\z@    % Number of bits encoded (in \qr@a) but not stored.
	% Encode the string based on the mode.
	\csname qr@encode@\qr@mode @mode\endcsname
	% Compute number of bits remaining.
	\count@=\numexpr8*\qr@total@data@words-\qr@gf@a\relax
	% Encode min(4,count@) 0 bits.
	\qr@b=\z@
	\ifnum\count@>4
		\qr@encode@bits{4}%
	\else
		\qr@encode@bits\count@
	\fi
	% Encode enough bits to get to a multiple of 8.
	\ifnum\qr@c>\z@
		\count@=\numexpr8-\qr@c\relax
		\qr@encode@bits\count@
	\fi
	% Now add padding words.
	% Number of words of padding (we can use eTeX's rounding division
	% because qr@gf@a is a multiple of 8 due to the final zero encodings
	% above).
	% Append 236 and 17 until the full size has been reached.
	\qr@for \qr@a=\qr@total@data@words-\qr@gf@a/8to\@ne by-\tw@{%
		\qr@append@word{236}%
		\qr@append@word{17}%
	}%
	\ifnum\qr@a>\z@
		\qr@append@word{236}%
	\fi
	\ifqr@dbg@data
		\qr@dump@matrix{qr@msg@1.}\qr@blks@per@groupi\qr@words@per@blki
		\qr@dump@matrix{qr@msg@2.}\qr@blks@per@groupii\qr@words@per@blkii
	\fi
}

% Debugging.
\newcommand\qr@dump@matrix[3]{%
	\begingroup
	\qr@make@matrix\qr@matrix{#1}%
	\qr@for \qr@gf@a=\z@ to#2by\@ne{%
		\message{#1\number\qr@gf@a\space =}%
		\qr@for \qr@gf@b=\z@ to#3by\@ne{%
			\message{\number\qr@matrix\qr@gf@a\qr@gf@b}%
		}
		\message{^^J}%
	}%
	\endgroup
}

% Debugging.
\newcommand*\qr@dump@poly[2]{%
	\begingroup
	\message{\string#1=(}%
	\qr@for \qr@a=#2to\z@ by\m@ne{%
		\message{\number#1{\qr@a}, }%
	}%
	\message{\number#1{\z@})^^J}%
	\endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compute error correcting code
%
% Compute the Reed--Solomon error correcting code for each block. Simply treat
% each block as the coefficients of a polynomial (using \qr@polynomial@view)
% and compute the polynomial remainder of division by the generator polynomial
% over GF(256).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@compute@ecc{%
	% Construct the generator polynomial.
	\qrgenpoly\qr@ecc@words@per@blk
	\qr@for \qr@c=\@ne to\thr@@ by\@ne{%
		% Compute the ECC for each block in group \qr@c
		% b = degree of msg polynomial
		\qr@b=\numexpr\csname qr@words@per@blk\romannumeral\qr@c\endcsname-\@ne\relax
		\qr@for \qr@a=\z@ to\csname qr@blks@per@group\romannumeral\qr@c\endcsname by\@ne{%
			\qr@polynomial@view\qr@result{qr@ecc@\number\qr@c.\number\qr@a.}{\qr@ecc@words@per@blk-\@ne}%
			\qr@polynomial@view\qr@divisor{qr@msg@\number\qr@c.\number\qr@a.}\qr@b
			\qr@poly@remainder
				\qr@result
				\qr@divisor\qr@b
				\qrgen\qr@ecc@words@per@blk
		}%
	}%
	\ifqr@dbg@ecc
		\qr@dump@matrix{qr@ecc@1.}\qr@blks@per@groupi\qr@ecc@words@per@blk
		\qr@dump@matrix{qr@ecc@2.}\qr@blks@per@groupii\qr@ecc@words@per@blk
	\fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Interleaved view of codewords
%
% This can be used to access the idx-th msg or ecc codeword.
% \qr@interleave{arr}{wordsPerBlki}{idx}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@interleave[3]{%
	% Compute the column first.
	\csname#1\expandafter\qr@interleave@column\expandafter
		{\number\qr@div{#3}\qr@total@blks}{#2}{#3}%
	\endcsname
}

% \qr@interleave@column{column}{wordsPerBlki}{idx}
\def\qr@interleave@column#1#2#3{%
	% The block number is idx-column*total@blks.
	\expandafter\qr@interleave@blk\expandafter
		{\number\numexpr#3-#1*\qr@total@blks\relax}{#1}{#2}{#3}%
}

% \qr@interleave@blk{block}{column}{wordsPerBlki}{idx}
\def\qr@interleave@blk#1#2#3#4{%
	\ifnum#2=\numexpr#3\relax
		% This must be the final column and since the column number is
		% the number of words per block in group 1, this must be in
		% group 2. Thus the block number is actually block.
		2.#1.#2%
	\else
		% Either this is not the final column or all groups have the
		% same number of words per block.
		\ifnum#1<\qr@blks@per@groupi
			% Group 1.
			1.#1.#2%
		\else
			% Group 2.
			2.\number\numexpr#1-\qr@blks@per@groupi\relax.#2%
		\fi
	\fi
}

% eTeX's \numexpr ... \relax rounds division! Compensate for that. Both
% \qr@div and \qr@mod require positive integers.
\def\qr@div#1#2{%
	\expandafter\qr@divx\expandafter
	{\number\numexpr#1\expandafter\relax\expandafter}\expandafter
	{\number\numexpr#2\relax}%
}
\def\qr@divx#1#2{%
	\expandafter\qr@divy\expandafter{\number\numexpr#1/#2\relax}{#1}{#2}%
}
\def\qr@divy#1#2#3{%
	\numexpr#1
	\ifnum#2<\numexpr#1*#3\relax
		-\@ne
	\fi
	\relax
}

\def\qr@mod#1#2{%
	\expandafter\qr@modx\expandafter
	{\the\numexpr#1\expandafter\relax\expandafter}\expandafter
	{\the\numexpr#2\relax}%
}
\def\qr@modx#1#2{\numexpr#1-#2*\qr@divx{#1}{#2}\relax}

\def\qr@modii#1{%
	\ifodd\numexpr#1\relax
		\expandafter\@ne
	\else
		\expandafter\z@
	\fi
}

\def\qr@modiii#1{\qr@mod{#1}\thr@@}

\qr@make@matrix\qr@module{qr@m@}
\qr@make@matrix\qr@maskedi{qr@M1@}
\qr@make@matrix\qr@maskedii{qr@M2@}

\def\qr@module@set{\qr@matrix@set\qr@current@matrix}

\chardef\qr@white=\z@
\chardef\qr@black=\@ne
\chardef\qr@function@white=\tw@
\chardef\qr@function@black=\thr@@
\chardef\qr@blank=254

% Iterate over all module values (qr@gf@a, qr@gf@b) = (row, col).
\def\qr@foreach@module#1{%
	\qr@for \qr@gf@a=\z@ to\qr@num@modules by\@ne{%
		\qr@for \qr@gf@b=\z@ to\qr@num@modules by\@ne{#1}%
	}%
}

\def\qr@zero@modules{%
	\qr@foreach@module{%
		% Place this in a group so that the save stack doesn't fill
		% with useless entries.
		\begingroup
		\global\expandafter\let\csname qr@m@\number\qr@gf@a.\number\qr@gf@b\endcsname\qr@blank
		\global\expandafter\let\csname qr@M1@\number\qr@gf@a.\number\qr@gf@b\endcsname\relax
		\global\expandafter\let\csname qr@M2@\number\qr@gf@a.\number\qr@gf@b\endcsname\relax
		\endgroup
	}%
}

% Generic addition of modules starting at (\qr@gf@a, \qr@gf@b) and updated
% according to \qr@v. Modules end with \relax.
\def\qr@add@generic#1{%
	\ifx\relax#1\else
		\qr@module@set{\qr@gf@a}{\qr@gf@b}{#1}%
		\qr@v
		\expandafter\qr@add@generic
	\fi
}


% Add row, increment \qr@gf@a afterword.
\def\qr@add@row#1{%
	%\begingroup
	\chardef\qr@save=\qr@gf@b
	\def\qr@v{\advance\qr@gf@b\@ne}%
	\qr@add@generic#1\relax
	\qr@gf@b\qr@save
	%\endgroup
	\advance\qr@gf@a\@ne
}

\def\qr@add@row@at#1#2{%
	\qr@gf@a=\numexpr#1\relax
	\qr@gf@b=\numexpr#2\relax
	\qr@add@row
}

% Add col, increment \qr@gf@b afterword.
\def\qr@add@col#1{%
	%\begingroup
	\chardef\qr@save\qr@gf@a
	\def\qr@v{\advance\qr@gf@a\@ne}%
	\qr@add@generic#1\relax
	\qr@gf@a=\qr@save
	%\endgroup
	\advance\qr@gf@b\@ne
}

\def\qr@add@col@at#1#2{%
	\qr@gf@a=\numexpr#1\relax
	\qr@gf@b=\numexpr#2\relax
	\qr@add@col
}

% Add a finder pattern with separators.
\def\qr@add@finder#1#2{%
	\qr@add@row@at{#1}{#2}{3333333}%
	\qr@add@row{3222223}%
	\qr@add@row{3233323}%
	\qr@add@row{3233323}%
	\qr@add@row{3233323}%
	\qr@add@row{3222223}%
	\qr@add@row{3333333}%
	% Add separators.
	\ifnum\qr@gf@a=7 % Top left or right, so add below.
		\qr@add@row{2222222}%
		\ifnum\qr@gf@b=\z@ % Top left.
			\qr@add@col@at{\z@}{7}{22222222}%
		\else % Top right.
			\qr@add@col@at{\z@}{\qr@gf@b-\@ne}{22222222}%
		\fi
	\else % Bottom left.
		\qr@add@row@at{(#1)-\@ne}{\z@}{22222222}%
		\qr@add@col@at{\qr@gf@a}{7}{2222222}%
	\fi
}

\def\qr@alignment@row{\afterassignment\qr@alignment@rowx\qr@gf@a=}
\def\qr@alignment@rowx{%
	\ifnum\qr@gf@a>\z@
		\advance\qr@gf@a-\tw@
		\qr@alignment@col\qr@alignments\z@
		\expandafter\qr@alignment@row
	\fi
}

\def\qr@alignment@col{\afterassignment\qr@alignment@colx\qr@gf@b=}%
\def\qr@alignment@colx{%
	\ifnum\qr@gf@b>\z@
		\advance\qr@gf@b-\tw@
		\ifnum\qr@module{\qr@gf@a}{\qr@gf@b}=\qr@blank
		\ifnum\qr@module{\qr@gf@a+5}{\qr@gf@b}=\qr@blank
		\ifnum\qr@module{\qr@gf@a}{\qr@gf@b+5}=\qr@blank
			\qr@add@row{33333}%
			\qr@add@row{32223}%
			\qr@add@row{32323}%
			\qr@add@row{32223}%
			\qr@add@row{33333}%
			\advance\qr@gf@a-5
		\fi\fi\fi
		\expandafter\qr@alignment@col
	\fi
}

\def\qr@add@timing{%
	\qr@for \qr@a=8 to\qr@num@modules-8by\@ne{%
		\ifodd\qr@a
			\qr@module@set{\qr@a}{6}{\qr@function@white}%
			\qr@module@set{6}{\qr@a}{\qr@function@white}%
		\else
			\qr@module@set{\qr@a}{6}{\qr@function@black}%
			\qr@module@set{6}{\qr@a}{\qr@function@black}%
		\fi
	}
}

% Add reserved space for format and version information as well as the dark
% module.
\def\qr@add@reserved{%
	% Add format reserved spaces.
	% Top left. Write the timing module to black.
	\qr@add@row@at{8}{\z@}{222222322}%
	\qr@add@col@at{\z@}{8}{22222232}%
	% Top right.
	\qr@add@row@at{8}{\qr@num@modules-8}{22222222}%
	% Bottom left. Include the dark module.
	\qr@add@col@at{\qr@num@modules-8}{8}{32222222}%
	% Add version reserved spaces for versions larger than 6.
	\ifnum\qr@ver>6
		\qr@add@row@at{\qr@num@modules-11}{\z@}{222222}%
		\qr@add@row{222222}%
		\qr@add@row{222222}%
		\qr@add@col@at{\z@}{\qr@num@modules-11}{222222}%
		\qr@add@col{222222}%
		\qr@add@col{222222}%
	\fi
}

% Add function patterns and separators
\def\qr@add@function@patterns{%
	%% Add Finder patterns and separators
	\qr@add@finder\z@\z@
	\qr@add@finder{\qr@ver*4+10}\z@
	\qr@add@finder\z@{\qr@ver*4+10}%
	% Add alignment patterns.
	\qr@set@alignments
	\qr@alignment@row\qr@alignments\z@
	%% Add timing patterns.
	\qr@add@timing
	%% Add format place holders (and dark module).
	\qr@add@reserved
}

% Add a module.
\def\qr@add@module#1{%
	%\message{\space\space(\number\qr@gf@a,\number\qr@gf@b)^^J}%
	\ifnum#1>\qr@c
		\qr@module@set{\qr@gf@a}{\qr@gf@b}{\qr@white}%
	\else
		\qr@module@set{\qr@gf@a}{\qr@gf@b}{\qr@black}%
		\advance\qr@c-#1\relax
	\fi
	\qr@advance@module@ptr
}

% Zig zag back and forth, ignoring function modules.
\def\qr@advance@module@ptr{%
	\ifqr@inrange
		\qr@inrangefalse
		\advance\qr@gf@b\m@ne
	\else
		\qr@inrangetrue
		% Move to the next row (either up or down).
		\advance\qr@gf@a\qr@gf@n
		\ifnum\qr@gf@a<\z@
			\qr@gf@n=\@ne
			\qr@gf@a=\z@
			\advance\qr@gf@b\m@ne
		\else\ifnum\qr@gf@a=\qr@num@modules
			\qr@gf@n=\m@ne
			\advance\qr@gf@a\m@ne
			\advance\qr@gf@b\m@ne
		\else
			\advance\qr@gf@b\@ne
		\fi\fi
		% If the column is 6 (the timing pattern), move left.
		\ifnum\qr@gf@b=6
			\qr@gf@b=5
		\fi
	\fi
	% If we moved onto a function pattern or reserved area, advance again,
	% unless we are finished.
	\ifnum\qr@gf@b>\m@ne
		\ifnum\qr@module{\qr@gf@a}{\qr@gf@b}=\qr@blank\else
			\expandafter\expandafter\expandafter
			\qr@advance@module@ptr
		\fi
	\fi
}

% Add words
\def\qr@add@words#1#2#3{%
	\qr@for \qr@idx=\z@ to#3by\@ne{%
		\qr@c=\qr@interleave{#1}{#2}\qr@idx
		%\message{Word \number\qr@c\space at
		%	(\number\qr@gf@a,\number\qr@gf@b)^^J}%
		\qr@add@module{128}%
		\qr@add@module{64}%
		\qr@add@module{\@xxxii}%
		\qr@add@module{\sixt@@n}%
		\qr@add@module{8}%
		\qr@add@module{4}%
		\qr@add@module{\tw@}%
		\qr@add@module{\@ne}%
	}%
}

% Add the data and remainder modules.
\def\qr@add@data@modules{%
	% Starting coordinates.
	\qr@gf@a=\numexpr\qr@num@modules-\@ne\relax
	\qr@gf@b=\qr@gf@a
	\qr@inrangetrue % On the right side of the column.
	\qr@gf@n=\m@ne % Going up.
	\qr@add@words{qr@msg@}\qr@words@per@blki\qr@total@data@words
	\qr@add@words{qr@ecc@}\qr@ecc@words@per@blk\qr@total@ecc@words
	% Remainder bits.
	\qr@while\ifnum\qr@gf@b>\m@ne{%
		\qr@module@set{\qr@gf@a}{\qr@gf@b}{\qr@white}%
		\qr@advance@module@ptr
	}\qr@repeat
}

\def\qr@eval@color@change#1#2{%
	\count@=\numexpr#2-#1\relax
	% Evaluation 3.
	\ifnum\qr@c=\qr@black
		\ifnum\count6=\count@
		\ifnum\count4=\numexpr\thr@@*\count@\relax
		\ifnum\count\tw@=\count@
		\ifnum\count\z@=\count@
			\advance\qr@gf@r40
		\fi\fi\fi\fi
		\count\z@=\count4
		\count4=\count@
	\else
		\count\tw@=\count6
		\count6=\count@
	\fi
	\ifnum\count@>4
		\advance\qr@gf@r\numexpr\count@-\tw@
	\fi
	#1=#2%
	\qr@c=\numexpr\@ne-\qr@c\relax
}

%\csdef{qr@mask@expr@0}{\qr@modii{\qr@gf@a+\qr@gf@b}}
%\csdef{qr@mask@expr@1}{\qr@modii\qr@gf@a}
%\csdef{qr@mask@expr@2}{\qr@modiii\qr@gf@b}
%\csdef{qr@mask@expr@3}{\qr@modiii{\qr@gf@a+\qr@gf@b}}
%\csdef{qr@mask@expr@4}{\qr@modii{\qr@div\qr@gf@a\tw@+\qr@div\qr@gf@b\thr@@}}
%\csdef{qr@mask@expr@5}{\qr@modii{\qr@gf@a*\qr@gf@b}+\qr@modiii{\qr@gf@a*\qr@gf@b}}
%\csdef{qr@mask@expr@6}{\qr@modii{\qr@modii{\qr@gf@a*\qr@gf@b}+\qr@modiii{\qr@gf@a*\qr@gf@b}}}
%\csdef{qr@mask@expr@7}{\qr@modii{\qr@modiii{\qr@gf@a*\qr@gf@b}+\qr@modii{\qr@gf@a+\qr@gf@b}}}

\csdef{qr@mask@expr@0}{%
	\count@\qr@gf@a
	\advance\count@\qr@gf@b
	\qr@gf@r\ifodd\count@\@ne\else\z@\fi
}
\csdef{qr@mask@expr@1}{%
	\qr@gf@r\ifodd\qr@gf@a\@ne\else\z@\fi
}
\csdef{qr@mask@expr@2}{%
	\qr@gf@r\qr@gf@b
	\divide\qr@gf@r\thr@@
	\multiply\qr@gf@r-\thr@@
	\advance\qr@gf@r\qr@gf@b
}
\csdef{qr@mask@expr@3}{%
	\count@\qr@gf@a
	\advance\count@\qr@gf@b
	\qr@gf@r\count@
	\divide\qr@gf@r\thr@@
	\multiply\qr@gf@r-\thr@@
	\advance\qr@gf@r\count@
}
\csdef{qr@mask@expr@4}{%
	\qr@gf@r\qr@gf@a
	\divide\qr@gf@r\tw@
	\count@\qr@gf@b
	\divide\count@\thr@@
	\advance\qr@gf@r\count@
	\qr@gf@r\ifodd\qr@gf@r\@ne\else\z@\fi
}
\csdef{qr@mask@expr@5}{%
	\count@\qr@gf@a
	\multiply\count@\qr@gf@b
	\qr@gf@r\count@
	\divide\qr@gf@r\thr@@
	\multiply\qr@gf@r-\thr@@
	\advance\qr@gf@r\count@
	\ifodd\count@\advance\qr@gf@r\@ne\fi
}
\csdef{qr@mask@expr@6}{%
	\count@\qr@gf@a
	\multiply\count@\qr@gf@b
	\qr@gf@r\count@
	\divide\qr@gf@r\thr@@
	\multiply\qr@gf@r-\thr@@
	\advance\qr@gf@r\count@
	\ifodd\count@\advance\qr@gf@r\@ne\fi
	\qr@gf@r\ifodd\qr@gf@r\@ne\else\z@\fi
}
\csdef{qr@mask@expr@7}{%
	\count@\qr@gf@a
	\multiply\count@\qr@gf@b
	\qr@gf@r\count@
	\divide\qr@gf@r\thr@@
	\multiply\qr@gf@r-\thr@@
	\advance\qr@gf@r\count@
	\advance\qr@gf@r\qr@gf@a
	\advance\qr@gf@r\qr@gf@b
	\qr@gf@r\ifodd\qr@gf@r\@ne\else\z@\fi
}

\def\qr@try@mask#1{%
	\letcs\qr@mask@expr{qr@mask@expr@\number#1}%
	\qr@foreach@module{%
		\qr@c\qr@module\qr@gf@a\qr@gf@b
		\ifnum\qr@c<\tw@
			%\ifnum\numexpr\qr@mask@expr\relax=\z@
			\qr@mask@expr
			\ifnum\qr@gf@r=\z@
				\qr@c-\qr@c
				\advance\qr@c\@ne
			\fi
		\else
			\qr@c\ifodd\qr@c \qr@black \else \qr@white \fi
		\fi
		\qr@matrix@set\qr@masked\qr@gf@a\qr@gf@b\qr@c
	}%
	\qr@gf@r=\z@
	% Perform the four evaluations in two passes.
	% Pass 1:
	% a = number of black modules
	% b = col, c = color
	% \count 0, 2, 4, 6 = extents of previous four colors
	\qr@a=\z@
	\qr@for \qr@gf@a=\z@ to\qr@num@modules by\@ne{%
		\qr@b=\z@
		\qr@c=\qr@white
		\count\z@=\z@
		\count\tw@=\z@
		\count4=\z@
		\count6=\z@
		\qr@for \qr@gf@b=\z@ to\qr@num@modules by\@ne{%
			\count@=\qr@masked{\qr@gf@a}{\qr@gf@b}%
			% Evaluation 4.
			\advance\qr@a\count@
			\ifnum\qr@c=\count@
				% Evaluation 2.
				\ifnum\qr@gf@a>\z@
				\ifnum\qr@gf@b>\z@
					\ifnum\qr@masked{\qr@gf@a-\@ne}{\qr@gf@b-\@ne}=\count@
					\ifnum\qr@masked{\qr@gf@a-\@ne}{\qr@gf@b}=\count@
						\advance\qr@gf@r\thr@@
					\fi\fi
				\fi\fi
			\else
				% Evaluations 1 and 3 (row).
				\qr@eval@color@change\qr@b\qr@gf@b
			\fi
		}%
		\qr@eval@color@change\qr@b\qr@gf@b
	}%
	% Evaluation 4.
	% 0 <= 5*a <= 100*black/total < 5*(a+1) <= 100
	% 0 <= a <= 20*black/total < a+1 <= 20
	\multiply\qr@a20
	\divide\qr@a\numexpr\qr@num@modules*\qr@num@modules\relax
	\qr@b=\numexpr\qr@a+\@ne\relax
	\advance\qr@a-10
	\ifnum\qr@a<\z@ \qr@a=-\qr@a \fi
	\advance\qr@b-10
	\ifnum\qr@b<\z@ \qr@a=-\qr@b \fi
	\advance\qr@gf@r\numexpr10*\ifnum\qr@a<\qr@b \qr@a \else \qr@b \fi\relax
	% Pass 2:
	% The outer loop moves over columns and the inner loop over rows (the
	% opposite of pass 1).
	% a = row, c = col
	% \count 0, 2, 4, 6 = extents of previous four colors
	\qr@for \qr@gf@b=\z@ to\qr@num@modules by\@ne{%
		\qr@a=\z@
		\qr@c=\qr@white
		\count\z@=\z@
		\count\tw@=\z@
		\count4=\z@
		\count6=\z@
		\qr@for \qr@gf@a=\z@ to\qr@num@modules by\@ne{%
			% Evaluations 1 and 3 (col)
			\ifnum\qr@c=\qr@masked{\qr@gf@a}{\qr@gf@b}\else
				\qr@eval@color@change\qr@a\qr@gf@a
			\fi
		}%
		\qr@eval@color@change\qr@a\qr@gf@a
	}%
	\ifqr@dbg@parameters \message{Mask #1 score: \number\qr@gf@r^^J}\fi
	\ifnum\qr@gf@r<\qr@gf@n
		\qr@gf@n=\qr@gf@r
		\chardef\qr@mask@pattern=#1\relax
		\ifnum\qr@masked@val=\tw@
			\let\qr@masked\qr@maskedii
			\chardef\qr@masked@val=\@ne
		\else
			\let\qr@masked\qr@maskedi
			\chardef\qr@masked@val=\tw@
		\fi
	\fi
}

\def\qr@mask@data{%
	\chardef\qr@masked@val=\tw@
	\let\qr@masked\qr@maskedi
	\qr@gf@n="3FFFFFFF
	\ifx\qr@requested@mask\qr@star
		\qr@try@mask0%
		\qr@try@mask1%
		\qr@try@mask2%
		\qr@try@mask3%
		\qr@try@mask4%
		\qr@try@mask5%
		\qr@try@mask6%
		\qr@try@mask7%
	\else
		\qr@try@mask\qr@requested@mask
	\fi
	\ifqr@dbg@parameters \message{Using mask \number\qr@mask@pattern^^J}\fi
	\letcs\qr@masked{qr@masked\romannumeral\qr@masked@val}%
}

% Format bits 14:8
\def\qr@format@high#1#2#3#4#5#6#7{%
	\qr@add@row@at{8}{\z@}{#1#2#3#4#5#6\qr@black#7}%
	\qr@add@col@at{\qr@num@modules-7}{8}{#7#6#5#4#3#2#1}%
	\qr@format@low
}

% Format bits 7:0
\def\qr@format@low#1#2#3#4#5#6#7#8{%
	\qr@add@row@at{8}{\qr@num@modules-8}{#1#2#3#4#5#6#7#8}%
	\qr@add@col@at{\z@}{8}{#8#7#6#5#4#3\qr@black#2#1}%
}

\def\qr@add@format{%
	\if      L\qr@ecl \qr@a=8
	\else\if M\qr@ecl \qr@a=\z@
	\else\if Q\qr@ecl \qr@a=24
	\else             \qr@a=16
	\fi\fi\fi
	\advance\qr@a\qr@mask@pattern
	\expandafter\qr@format@high
	\ifcase\qr@a 101010000010010%
	\or          101000100100101%
	\or          101111001111100%
	\or          101101101001011%
	\or          100010111111001%
	\or          100000011001110%
	\or          100111110010111%
	\or          100101010100000%
	\or          111011111000100%
	\or          111001011110011%
	\or          111110110101010%
	\or          111100010011101%
	\or          110011000101111%
	\or          110001100011000%
	\or          110110001000001%
	\or          110100101110110%
	\or          001011010001001%
	\or          001001110111110%
	\or          001110011100111%
	\or          001100111010000%
	\or          000011101100010%
	\or          000001001010101%
	\or          000110100001100%
	\or          000100000111011%
	\or          011010101011111%
	\or          011000001101000%
	\or          011111100110001%
	\or          011101000000110%
	\or          010010010110100%
	\or          010000110000011%
	\or          010111011011010%
	\or          010101111101101%
	\fi
}

% Version bits 17:9
\def\qr@version@high#1#2#3#4#5#6#7#8#9{%
	\qr@add@row@at{\thr@@}{\qr@num@modules-11}{#9#8#7}%
	\qr@add@row{#6#5#4}%
	\qr@add@row{#3#2#1}%
	\qr@add@col@at{\qr@num@modules-11}{\thr@@}{#9#8#7}%
	\qr@add@col{#6#5#4}%
	\qr@add@col{#3#2#1}%
	\qr@version@low
}

% Version bits 8:0
\def\qr@version@low#1#2#3#4#5#6#7#8#9{%
	\qr@add@row@at{\z@}{\qr@num@modules-11}{#9#8#7}%
	\qr@add@row{#6#5#4}%
	\qr@add@row{#3#2#1}%
	\qr@add@col@at{\qr@num@modules-11}{\z@}{#9#8#7}%
	\qr@add@col{#6#5#4}%
	\qr@add@col{#3#2#1}%
}

\def\qr@add@version{%
	\ifnum\qr@ver>6
		\expandafter\qr@version@high
		\ifcase\numexpr\qr@ver-7\relax
		    000111110010010100
		\or 001000010110111100
		\or 001001101010011001
		\or 001010010011010011
		\or 001011101111110110
		\or 001100011101100010
		\or 001101100001000111
		\or 001110011000001101
		\or 001111100100101000
		\or 010000101101111000
		\or 010001010001011101
		\or 010010101000010111
		\or 010011010100110010
		\or 010100100110100110
		\or 010101011010000011
		\or 010110100011001001
		\or 010111011111101100
		\or 011000111011000100
		\or 011001000111100001
		\or 011010111110101011
		\or 011011000010001110
		\or 011100110000011010
		\or 011101001100111111
		\or 011110110101110101
		\or 011111001001010000
		\or 100000100111010101
		\or 100001011011110000
		\or 100010100010111010
		\or 100011011110011111
		\or 100100101100001011
		\or 100101010000101110
		\or 100110101001100100
		\or 100111010101000001
		\or 101000110001101001
		\fi
	\fi
}

% \qr@make@module{box}{width}{height}{overlapwidth}{overlapdepth}{color}
\newcommand*\qr@make@color@box[6]{%
	\setbox#1=\color@hbox
		\color{#6}%
		\vrule\@width\dimexpr#2+#4\relax\@height#3\@depth#5%
	\color@endbox
	\wd#1=#2%
	\dp#1=\z@
}
\newcommand*\qr@make@modules[3]{%
	\qr@make@color@box\qr@white{#1}{#1}{#2}{#3}\qr@lightcolor
	\qr@make@color@box\qr@black{#1}{#1}{#2}{#3}\qr@darkcolor
}

\newcommand*\qr@draw{%
	\leavevmode
	\vbox{%
		\offinterlineskip
		\qr@b=\qr@num@modules
		\ifqr@quietzone
			\advance\qr@b8
		\fi
		\dimen@=\dimexpr(\qr@width)/\qr@b\relax
		% dimen2 is the normal overlap, dimen4 is the overlap for the
		% final row/column. When drawing the quiet zone, this is the
		% same as dimen2.
		\setlength{\dimen\tw@}{\qr@overlap}%
		\dimen4=\z@
		\qr@make@modules\dimen@{\dimen\tw@}{\dimen\tw@}%
		\qr@a=\numexpr\qr@num@modules-\@ne\relax
		\ifqr@quietzone
			\begingroup
			\dimen4=\dimen\tw@
			\qr@make@color@box8{\qr@b\dimen@}{4\dimen@}\z@{\dimen\tw@}{\qr@quietcolor}%
			\box8
			\hbox\bgroup
				\qr@make@color@box8{4\dimen@}{\qr@num@modules\dimen@}{\dimen\tw@}{\dimen\tw@}{\qr@quietcolor}%
				\box8
				\vbox\bgroup
		\fi
		% Actually draw.
		\qr@for \qr@gf@a=\z@ to\qr@a by\@ne{%
			\hbox{%
				\qr@for \qr@gf@b=\z@ to\qr@a by\@ne{%
					\copy\qr@masked\qr@gf@a\qr@gf@b
				}%
				% Final column.
				\qr@make@modules\dimen@{\dimen4}{\dimen\tw@}%
				\copy\qr@masked\qr@gf@a\qr@a
			}%
		}%
		% Final row
		\qr@make@modules\dimen@{\dimen\tw@}{\dimen4}%
		\hbox{%
			\qr@for \qr@gf@b=\z@ to\qr@a by\@ne{%
				\copy\qr@masked\qr@a\qr@gf@b
			}%
			% Final column.
			\qr@make@modules\dimen@{\dimen4}{\dimen4}%
			\copy\qr@masked\qr@a\qr@a
		}%
		\ifqr@quietzone
				\egroup
				\qr@make@color@box8{4\dimen@}{\qr@num@modules\dimen@}\z@{\dimen\tw@}{\qr@quietcolor}%
				\box8
			\egroup
			\qr@make@color@box8{\qr@b\dimen@}{4\dimen@}\z@\z@{\qr@quietcolor}%
			\box8
			\endgroup
		\fi
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create a QR code
%
% \qrcode[options]{str}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\qrcode[1][]{%
	\begingroup
	\setkeys{qr}{#1}%
	% Parse the message by making every character "other" except for \, {,
	% and }.
	\begingroup
	\qr@for\qr@a=\z@ to\@cclvi by\@ne{%
		\catcode\qr@a12
	}%
	\catcode`\\\z@
	\catcode`\{\@ne
	\catcode`\}\tw@
	\qr@parse
}

\begingroup
\catcode`\|\z@
\catcode`\(\@ne
\catcode`\)\tw@
\catcode`\{12
\catcode`\}12
\catcode`\\12
|gdef|qr@parse(%
	|edef||(\)%
	|edef|{({)%
	|edef|}(})%
	|afterassignment|qr@code
	|xdef|qr@msg
)
|endgroup

\def\qr@code{%
	\endgroup
	\ifqr@dbg@timing\else
		\let\qr@time\@firstofone
	\fi
	%\edef\qr@msg{\detokenize{#2}}%
	\qr@time\qr@analyze@msg
	\qr@time\qr@select@version
	\ifnum\qr@ver=\z@
		\PackageError{qr}%
			{String length \number\qr@len\space too long for
			\qr@mode-mode\MessageBreak at error compression level \qr@ecl}{}%
	\fi
	\ifx\qr@ecl\relax
		\PackageError{qr}%
			{String length \number\qr@len\space too long
			for \qr@mode-mode\MessageBreak for version \number\qr@ver}{}%
	\fi
	\qr@time\qr@set@parameters
	\message{QR Version: \number\qr@ver-\qr@ecl\space\qr@mode^^J}
	\qr@time\qr@encode@msg
	\qr@time\qr@compute@ecc
	\ifqr@dbg@interleave \qr@dump@interleaved@data \fi
	% Construct matrix.
	\chardef\qr@num@modules=\numexpr\qr@ver*4+17\relax
	\qr@time\qr@zero@modules
	\let\qr@current@matrix\qr@module
	\qr@time\qr@add@function@patterns
	\qr@time\qr@add@data@modules
	\qr@time\qr@mask@data
	\let\qr@current@matrix\qr@masked
	\qr@time\qr@add@format
	\qr@time\qr@add@version
	\qr@time\qr@draw
	\global\let\qr@msg\relax
	\endgroup
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Debugging.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\qr@time[1]{%
	\pdfresettimer
	#1%
	\count@=\pdfelapsedtime
	\message{Timing \detokenize{#1}: \the\count@^^J}%
}

\newcommand*\qr@dump@data{%
	\qr@reset@data@ptr
	\loop\ifnum\qr@grp<\thr@@
		\number\csname qr@msg@\number\qr@grp.\number\qr@blk.\number\qr@idx\endcsname
		\qr@advance@data@ptr
		\
	\repeat
}

\newcommand*\qr@dump@interleaved@data{%
	\message{Interleaved data:^^J}%
	\qr@idx=\z@
	\loop\ifnum\qr@idx<\qr@total@data@words
		\message{\number\qr@interleave{qr@msg@}\qr@words@per@blki\qr@idx}%
		\advance\qr@idx\@ne
	\repeat
	\message{^^JInterleaved ecc:^^J}%
	\qr@idx=\z@
	\loop\ifnum\qr@idx<\qr@total@ecc@words
		\message{\number\qr@interleave{qr@ecc@}\qr@ecc@words@per@blk\qr@idx}%
		\advance\qr@idx\@ne
	\repeat
	\message{^^J}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Table-generated code for QR version
%
% Select the minimal QR version for the mode based on the error correction
% level. \qr@v is defined to compare \qr@len to the appropriate parameter
% (based on the correction level) and if \qr@len is smaller, set \qr@ver to
% the first parameter.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\qr@select@version@numeric@mode{%
	\qr@v 40 7090 5597 3994 3058.%
	\qr@v 39 6744 5314 3792 2928.%
	\qr@v 38 6480 5040 3600 2736.%
	\qr@v 37 6154 4776 3418 2626.%
	\qr@v 36 5837 4589 3245 2525.%
	\qr@v 35 5530 4344 3082 2362.%
	\qr@v 34 5254 4135 2950 2302.%
	\qr@v 33 4966 3910 2806 2158.%
	\qr@v 32 4687 3694 2671 2023.%
	\qr@v 31 4418 3487 2474 1898.%
	\qr@v 30 4159 3290 2359 1783.%
	\qr@v 29 3910 3036 2182 1678.%
	\qr@v 28 3670 2858 2086 1582.%
	\qr@v 27 3518 2702 1934 1502.%
	\qr@v 26 3284 2545 1805 1426.%
	\qr@v 25 3058 2396 1719 1287.%
	\qr@v 24 2813 2189 1589 1229.%
	\qr@v 23 2621 2060 1469 1109.%
	\qr@v 22 2410 1873 1359 1057.%
	\qr@v 21 2233 1709 1225 970.%
	\qr@v 20 2062 1601 1160 920.%
	\qr@v 19 1904 1501 1064 814.%
	\qr@v 18 1726 1347 949 747.%
	\qr@v 17 1549 1213 877 675.%
	\qr@v 16 1409 1083 776 603.%
	\qr@v 15 1251 992 704 531.%
	\qr@v 14 1102 872 622 469.%
	\qr@v 13 1023 797 581 428.%
	\qr@v 12 884 692 490 375.%
	\qr@v 11 773 605 428 332.%
	\qr@v 10 653 514 365 289.%
	\qr@v 9 553 433 313 236.%
	\qr@v 8 462 366 260 203.%
	\qr@v 7 371 294 208 155.%
	\qr@v 6 323 256 179 140.%
	\qr@v 5 256 203 145 107.%
	\qr@v 4 188 150 112 83.%
	\qr@v 3 128 102 78 59.%
	\qr@v 2 78 64 49 35.%
	\qr@v 1 42 35 28 18.%
}

\def\qr@select@version@alphanum@mode{%
	\qr@v 40 4297 3392 2421 1853.%
	\qr@v 39 4088 3221 2299 1775.%
	\qr@v 38 3928 3055 2182 1659.%
	\qr@v 37 3730 2895 2072 1592.%
	\qr@v 36 3538 2781 1967 1531.%
	\qr@v 35 3352 2633 1868 1432.%
	\qr@v 34 3184 2507 1788 1395.%
	\qr@v 33 3010 2370 1701 1308.%
	\qr@v 32 2841 2239 1619 1227.%
	\qr@v 31 2678 2114 1500 1151.%
	\qr@v 30 2521 1995 1430 1081.%
	\qr@v 29 2370 1840 1323 1017.%
	\qr@v 28 2224 1733 1264 959.%
	\qr@v 27 2133 1638 1173 911.%
	\qr@v 26 1991 1543 1095 865.%
	\qr@v 25 1854 1452 1042 780.%
	\qr@v 24 1705 1327 964 745.%
	\qr@v 23 1589 1249 891 673.%
	\qr@v 22 1461 1135 824 641.%
	\qr@v 21 1353 1036 743 588.%
	\qr@v 20 1250 971 703 558.%
	\qr@v 19 1154 910 645 494.%
	\qr@v 18 1047 817 575 453.%
	\qr@v 17 939 735 532 409.%
	\qr@v 16 855 657 471 366.%
	\qr@v 15 759 601 427 322.%
	\qr@v 14 668 529 377 284.%
	\qr@v 13 620 484 353 260.%
	\qr@v 12 536 420 297 228.%
	\qr@v 11 469 367 260 201.%
	\qr@v 10 396 312 222 175.%
	\qr@v 9 336 263 190 144.%
	\qr@v 8 280 222 158 123.%
	\qr@v 7 225 179 126 94.%
	\qr@v 6 196 155 109 85.%
	\qr@v 5 155 123 88 65.%
	\qr@v 4 115 91 68 51.%
	\qr@v 3 78 62 48 36.%
	\qr@v 2 48 39 30 21.%
	\qr@v 1 26 21 17 11.%
}

\def\qr@select@version@byte@mode{%
	\qr@v 40 2954 2332 1664 1274.%
	\qr@v 39 2810 2214 1580 1220.%
	\qr@v 38 2700 2100 1500 1140.%
	\qr@v 37 2564 1990 1424 1094.%
	\qr@v 36 2432 1912 1352 1052.%
	\qr@v 35 2304 1810 1284 984.%
	\qr@v 34 2189 1723 1229 959.%
	\qr@v 33 2069 1629 1169 899.%
	\qr@v 32 1953 1539 1113 843.%
	\qr@v 31 1841 1453 1031 791.%
	\qr@v 30 1733 1371 983 743.%
	\qr@v 29 1629 1265 909 699.%
	\qr@v 28 1529 1191 869 659.%
	\qr@v 27 1466 1126 806 626.%
	\qr@v 26 1368 1060 752 594.%
	\qr@v 25 1274 998 716 536.%
	\qr@v 24 1172 912 662 512.%
	\qr@v 23 1092 858 612 462.%
	\qr@v 22 1004 780 566 440.%
	\qr@v 21 930 712 510 404.%
	\qr@v 20 859 667 483 383.%
	\qr@v 19 793 625 443 339.%
	\qr@v 18 719 561 395 311.%
	\qr@v 17 645 505 365 281.%
	\qr@v 16 587 451 323 251.%
	\qr@v 15 521 413 293 221.%
	\qr@v 14 459 363 259 195.%
	\qr@v 13 426 332 242 178.%
	\qr@v 12 368 288 204 156.%
	\qr@v 11 322 252 178 138.%
	\qr@v 10 272 214 152 120.%
	\qr@v 9 231 181 131 99.%
	\qr@v 8 193 153 109 85.%
	\qr@v 7 155 123 87 65.%
	\qr@v 6 135 107 75 59.%
	\qr@v 5 107 85 61 45.%
	\qr@v 4 79 63 47 35.%
	\qr@v 3 54 43 33 25.%
	\qr@v 2 33 27 21 15.%
	\qr@v 1 18 15 12 8.%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Table-generated alignment mark cordinates.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\qr@set@alignments{%
	\edef\qr@alignments{%
		\ifcase\qr@ver
		\or  % 1
		\or 6 18 % 2
		\or 6 22 % 3
		\or 6 26 % 4
		\or 6 30 % 5
		\or 6 34 % 6
		\or 6 22 38 % 7
		\or 6 24 42 % 8
		\or 6 26 46 % 9
		\or 6 28 50 % 10
		\or 6 30 54 % 11
		\or 6 32 58 % 12
		\or 6 34 62 % 13
		\or 6 26 46 66 % 14
		\or 6 26 48 70 % 15
		\or 6 26 50 74 % 16
		\or 6 30 54 78 % 17
		\or 6 30 56 82 % 18
		\or 6 30 58 86 % 19
		\or 6 34 62 90 % 20
		\or 6 28 50 72 94 % 21
		\or 6 26 50 74 98 % 22
		\or 6 30 54 78 102 % 23
		\or 6 28 54 80 106 % 24
		\or 6 32 58 84 110 % 25
		\or 6 30 58 86 114 % 26
		\or 6 34 62 90 118 % 27
		\or 6 26 50 74 98 122 % 28
		\or 6 30 54 78 102 126 % 29
		\or 6 26 52 78 104 130 % 30
		\or 6 30 56 82 108 134 % 31
		\or 6 34 60 86 112 138 % 32
		\or 6 30 58 86 114 142 % 33
		\or 6 34 62 90 118 146 % 34
		\or 6 30 54 78 102 126 150 % 35
		\or 6 24 50 76 102 128 154 % 36
		\or 6 28 54 80 106 132 158 % 37
		\or 6 32 58 84 110 136 162 % 38
		\or 6 26 54 82 110 138 166 % 39
		\or 6 30 58 86 114 142 170 % 40
		\fi
	}%
}
